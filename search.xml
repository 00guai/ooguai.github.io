<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>剑指 Offer  DFS深度优先遍历</title>
      <link href="/2023/02/05/%E5%89%91%E6%8C%87%20Offer%20%20DFS%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
      <url>/2023/02/05/%E5%89%91%E6%8C%87%20Offer%20%20DFS%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>常使用递归进行向下应用</p></blockquote><h1 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a>剑指 Offer 12. 矩阵中的路径</h1><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>先从头遍历矩阵，找到第一个符合的字符，开始深度优先遍历</li><li>深度优先遍历：<br>定义 index 代表索引，或者说已经匹配了多少个字符<br>要写递归的出口：i、j 越界或者字符不匹配<br>匹配成功：index 等于 word.length - 1，匹配成功，直接返回 true<br>为了同一个单元格内的字母不允许被重复使用，遍历到某字符后，将当前字符设置为’’，防止四个方向 dfs 再次遍历到<br>四个方向遍历完毕后，再恢复这个字符</li><li>最后一只匹配失败，返回 false</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p><blockquote><blockquote><p>输入：board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “ABCCED”<br>输出：true</p></blockquote></blockquote><blockquote><blockquote><p>输入：board &#x3D; [[“a”,”b”],[“c”,”d”]], word &#x3D; “abcd”<br>输出：false</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var exist = function(board, word) &#123;<br><br>    const [m,n] = [board.length,board[0].length]<br><br>    const dfs = (i,j,index) => &#123;<br>        // 越界 || 字符不匹配<br>        if(i<0||i>=m||j<0||j>=n||board[i][j] !== word[index])<br>        return false<br>        // 索引等于单词长度-1，就匹配成功<br>        if(index === word.length-1)<br>        return true<br>        // 保存当前字符<br>        const temp = board[i][j]<br>        // 将当前字符设置为空，防止四个方向dfs再次遍历到<br>        board[i][j] = &#x27;&#x27;<br>        // 四个方向遍历<br>        const res =<br>        dfs(i+1,j,index+1) ||<br>        dfs(i,j+1,index+1) ||<br>        dfs(i-1,j,index+1) ||<br>        dfs(i,j-1,index+1)<br>        // 恢复当前字符<br>        board[i][j] =temp<br>        return res<br><br>    &#125;<br><br>    // 从第一个字符开始匹配<br>    for(let i=0;i<m;i++)&#123;<br>        for(let j=0;j<n;j++)&#123;<br>            if(dfs(i,j,0)) return true<br>        &#125;<br>    &#125;<br>    return false<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a>剑指 Offer 32 - II. 从上到下打印二叉树 II</h1><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>1.整一个队列</p><p>2.整一个结果 res，并提前</p><p>3.根据 quene.length 来进行 for 循环，分别继续判断子树</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>给定二叉树: [3,9,20,null,null,15,7],</p><p>返回其层次遍历结果：</p><blockquote><blockquote><p>[<br>[3],<br>[9,20],<br>[15,7]<br>]</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var levelOrder = function(root) &#123;<br>// 1 基础工作<br>const res = []<br>const quene = []<br>if(!root) return []<br>// 2 根节点推入<br>quene.push(root)<br>while(quene.length)&#123;<br>// 2.1 队列长度<br>let curlength = quene.length<br>res.push([])<br><br>        for(i=0;i<curlength;i++)&#123;<br>            // 2.3<br>            let node = quene.shift()<br>            res[res.length-1].push(node.val)<br>            // 3.0 将子节点导入队列，继续子节点<br>            if(node.left)  quene.push(node.left)<br>            if(node.right)  quene.push(node.right)<br>        &#125;<br>    &#125;<br>    return res<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a>剑指 Offer 32 - III. 从上到下打印二叉树 III</h1><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>1.与上大致相同，但增加了 odevity，判断奇偶</p><p>2.了解 push 和 unshift 两个方法</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>给定二叉树: [3,9,20,null,null,15,7],</p><p>返回其层次遍历结果：</p><blockquote><blockquote><p>[<br>[3],<br>[20,9],<br>[15,7]<br>]</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var levelOrder = function(root) &#123;<br><br>    // 1，基础工作<br>    const res = []<br>    const quene = [root]<br>    if(!root)  return []<br><br>    let odevity = true<br>    while(quene.length)&#123;<br>        let list = []<br>        const size = quene.length<br>        // 3.1建立for循环，遍历也可插入节点至有括号的list中<br>        for(let i=0;i<size;i++)&#123;<br>            // 3.2将队列中的shift出来赋为node<br>            let node = quene.shift()<br>            // 3.5根据odevity来检测从左至右，还是从右至左<br>            if(odevity === true)&#123;<br>                list.push(node.val)<br>            &#125;else&#123;<br>                list.unshift(node.val)<br>            &#125;<br>            // 3.8将子树也push至quene中<br>            if(node.left)&#123;<br>                quene.push(node.left)<br>            &#125;<br>            if(node.right)&#123;<br>                quene.push(node.right)<br>            &#125;<br><br><br>        &#125;<br>        // 3.9将odevity取反继续while<br>            odevity = !odevity<br>            res.push(list)<br><br>    &#125;return res<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="剑指-Offer-54-二叉搜索树的第-k-大节点"><a href="#剑指-Offer-54-二叉搜索树的第-k-大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第 k 大节点"></a>剑指 Offer 54. 二叉搜索树的第 k 大节点</h1><p>给定一棵二叉搜索树，请找出其中第 k 大的节点的值。</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>1.先递归右子树，即大的子树，把最大的节点放进队列</p><p>2.再直接将根节点放进队列</p><p>3.再去取左子树节点，同理放入队列</p><p>4.采用中序遍历的方法</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><blockquote><blockquote><p>输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1<br>3<br>&#x2F; <br> 1 4<br><br> 2<br>输出: 4</p></blockquote></blockquote><blockquote><blockquote><p>输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3<br>5<br>&#x2F; <br> 3 6<br>&#x2F; <br> 2 4<br>&#x2F;<br>1<br>输出: 4</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var kthLargest = function(root, k) &#123;<br><br>    // 使用反中序遍历<br>    let setArray = []<br>    const dfs = function(node)&#123;<br>        if(node === null)&#123;<br>            return<br>        &#125;<br><br>        // 先获取较大的值，将它推入数组的前面<br>        dfs(node.right)<br>        setArray.push(node.val)<br>        dfs(node.left)<br><br>    &#125;<br>    dfs(root)<br>    return setArray[k-1]<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><p>剑指 Offer 55 - I. 二叉树的深度</p><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p><strong>给的数字数组是升序排列的，故用双指针法求解：</strong></p><p>1.定义双指针分别指向数组头尾，即最小、最大的数</p><p>2.判断左右指针对应的数之和，与目标数的关系</p><p>3.若大于目标数，需要小一点，右指针左移</p><p>4.若小于目标数，需要大一点，左指针右移</p><p>5.若等于目标数，返回这两个数</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>给定二叉树 [3,9,20,null,null,15,7]，</p><blockquote><blockquote><pre><code>3</code></pre><p>&#x2F; <br> 9 20<br>&#x2F; <br> 15 7</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var maxDepth = function(root) &#123;<br><br>    if(root == null) return 0<br><br>    let quene = []<br>    quene.push(root)<br>    let k = 0<br>    while(quene.length)&#123;<br>        let size = quene.length<br><br>        for(let i=0;i<size;i++)&#123;<br>            // 先将node推出，并识别<br>            let node = quene.shift()<br>            if(node.left) quene.push(node.left)<br>            if(node.right) quene.push(node.right)<br>        &#125;<br>        k+=1<br>    &#125;<br>    return k<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a>剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</h1><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt="code"></p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>1.p,q 跟当前 root 比，都大往右，都小往左</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><blockquote><blockquote><p>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。</p></blockquote></blockquote><blockquote><blockquote><p>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var lowestCommonAncestor = function(root, p, q) &#123;<br><br>    // 客观情况<br>    if(!root) return null<br>    if(p.val == q.val) return p<br><br>    while(root)&#123;<br>        // 如果两个值都大于root，就把root.right赋给root<br>        if(root.val<p.val && root.val<q.val)&#123;<br>            root = root.right<br>        &#125;else if(root.val>p.val && root.val>q.val)&#123;<br>            root = root.left<br>        &#125;else&#123;<br>            // 当其中一个值等于或一大一小，就返回<br>            return root<br>        &#125;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 Offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 树</title>
      <link href="/2023/02/04/%E5%89%91%E6%8C%87%20Offer%20%E6%A0%91/"/>
      <url>/2023/02/04/%E5%89%91%E6%8C%87%20Offer%20%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>常使用递归进行向下应用</p></blockquote><h1 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a>剑指 Offer 32 - I. 从上到下打印二叉树</h1><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>实际上就是树的广度优先遍历。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>给定二叉树: [3,9,20,null,null,15,7],</p><blockquote><blockquote><p>3<br>&#x2F; <br> 9 20<br>&#x2F; <br>15 7</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var levelOrder = function(root) &#123;<br><br>    // 1.1先把结果声明出来<br>    const res = []<br>    //1.2 声明一个队列<br>    const que = []<br>    // 1.3客观情况<br>    if(!root)  return []<br>    // 2.0将根节点推入队列<br>    que.push(root)<br>    // ? : 应该知道此处添加到res中的是值<br>    // 2.1队列有值开始运行<br>    while(que.length>0)&#123;<br>        // 2.3将根节点的值放入res中<br>        let cur = que.shift();<br>        res.push(cur.val);<br><br>        // 3.0如果有左右子树，继续执行<br>        if(cur.left)&#123;<br>            que.push(cur.left)<br>        &#125;<br>        if(cur.right)&#123;<br>            que.push(cur.right)<br>        &#125;<br><br>    &#125;<br>    return res<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a>剑指 Offer 32 - II. 从上到下打印二叉树 II</h1><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>1.整一个队列</p><p>2.整一个结果 res，并提前</p><p>3.根据 quene.length 来进行 for 循环，分别继续判断子树</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>给定二叉树: [3,9,20,null,null,15,7],</p><p>返回其层次遍历结果：</p><blockquote><blockquote><p>[<br>[3],<br>[9,20],<br>[15,7]<br>]</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var levelOrder = function(root) &#123;<br>// 1 基础工作<br>const res = []<br>const quene = []<br>if(!root) return []<br>// 2 根节点推入<br>quene.push(root)<br>while(quene.length)&#123;<br>// 2.1 队列长度<br>let curlength = quene.length<br>res.push([])<br><br>        for(i=0;i<curlength;i++)&#123;<br>            // 2.3<br>            let node = quene.shift()<br>            res[res.length-1].push(node.val)<br>            // 3.0 将子节点导入队列，继续子节点<br>            if(node.left)  quene.push(node.left)<br>            if(node.right)  quene.push(node.right)<br>        &#125;<br>    &#125;<br>    return res<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a>剑指 Offer 32 - III. 从上到下打印二叉树 III</h1><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>1.与上大致相同，但增加了 odevity，判断奇偶</p><p>2.了解 push 和 unshift 两个方法</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>给定二叉树: [3,9,20,null,null,15,7],</p><p>返回其层次遍历结果：</p><blockquote><blockquote><p>[<br>[3],<br>[20,9],<br>[15,7]<br>]</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var levelOrder = function(root) &#123;<br><br>    // 1，基础工作<br>    const res = []<br>    const quene = [root]<br>    if(!root)  return []<br><br>    let odevity = true<br>    while(quene.length)&#123;<br>        let list = []<br>        const size = quene.length<br>        // 3.1建立for循环，遍历也可插入节点至有括号的list中<br>        for(let i=0;i<size;i++)&#123;<br>            // 3.2将队列中的shift出来赋为node<br>            let node = quene.shift()<br>            // 3.5根据odevity来检测从左至右，还是从右至左<br>            if(odevity === true)&#123;<br>                list.push(node.val)<br>            &#125;else&#123;<br>                list.unshift(node.val)<br>            &#125;<br>            // 3.8将子树也push至quene中<br>            if(node.left)&#123;<br>                quene.push(node.left)<br>            &#125;<br>            if(node.right)&#123;<br>                quene.push(node.right)<br>            &#125;<br><br><br>        &#125;<br>        // 3.9将odevity取反继续while<br>            odevity = !odevity<br>            res.push(list)<br><br>    &#125;return res<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="剑指-Offer-54-二叉搜索树的第-k-大节点"><a href="#剑指-Offer-54-二叉搜索树的第-k-大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第 k 大节点"></a>剑指 Offer 54. 二叉搜索树的第 k 大节点</h1><p>给定一棵二叉搜索树，请找出其中第 k 大的节点的值。</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>1.先递归右子树，即大的子树，把最大的节点放进队列</p><p>2.再直接将根节点放进队列</p><p>3.再去取左子树节点，同理放入队列</p><p>4.采用中序遍历的方法</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><blockquote><blockquote><p>输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1<br>3<br>&#x2F; <br> 1 4<br><br> 2<br>输出: 4</p></blockquote></blockquote><blockquote><blockquote><p>输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3<br>5<br>&#x2F; <br> 3 6<br>&#x2F; <br> 2 4<br>&#x2F;<br>1<br>输出: 4</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var kthLargest = function(root, k) &#123;<br><br>    // 使用反中序遍历<br>    let setArray = []<br>    const dfs = function(node)&#123;<br>        if(node === null)&#123;<br>            return<br>        &#125;<br><br>        // 先获取较大的值，将它推入数组的前面<br>        dfs(node.right)<br>        setArray.push(node.val)<br>        dfs(node.left)<br><br>    &#125;<br>    dfs(root)<br>    return setArray[k-1]<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><p>剑指 Offer 55 - I. 二叉树的深度</p><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p><strong>给的数字数组是升序排列的，故用双指针法求解：</strong></p><p>1.定义双指针分别指向数组头尾，即最小、最大的数</p><p>2.判断左右指针对应的数之和，与目标数的关系</p><p>3.若大于目标数，需要小一点，右指针左移</p><p>4.若小于目标数，需要大一点，左指针右移</p><p>5.若等于目标数，返回这两个数</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>给定二叉树 [3,9,20,null,null,15,7]，</p><blockquote><blockquote><pre><code>3</code></pre><p>&#x2F; <br> 9 20<br>&#x2F; <br> 15 7</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var maxDepth = function(root) &#123;<br><br>    if(root == null) return 0<br><br>    let quene = []<br>    quene.push(root)<br>    let k = 0<br>    while(quene.length)&#123;<br>        let size = quene.length<br><br>        for(let i=0;i<size;i++)&#123;<br>            // 先将node推出，并识别<br>            let node = quene.shift()<br>            if(node.left) quene.push(node.left)<br>            if(node.right) quene.push(node.right)<br>        &#125;<br>        k+=1<br>    &#125;<br>    return k<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a>剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</h1><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt="code"></p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>1.p,q跟当前root比，都大往右，都小往左</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><blockquote><blockquote><p>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。</p></blockquote></blockquote><blockquote><blockquote><p>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var lowestCommonAncestor = function(root, p, q) &#123;<br>    <br>    // 客观情况<br>    if(!root) return null<br>    if(p.val == q.val) return p<br><br>    while(root)&#123;<br>        // 如果两个值都大于root，就把root.right赋给root<br>        if(root.val<p.val && root.val<q.val)&#123;<br>            root = root.right<br>        &#125;else if(root.val>p.val && root.val>q.val)&#123;<br>            root = root.left<br>        &#125;else&#123;<br>            // 当其中一个值等于或一大一小，就返回<br>            return root<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 Offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>恋爱日记</title>
      <link href="/2023/02/01/%E6%81%8B%E7%88%B1%E6%97%A5%E8%AE%B0/"/>
      <url>/2023/02/01/%E6%81%8B%E7%88%B1%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="06052dafeacc1a6b27617335e493d50948abc894b740b455ee9fdbf4fa45160c">f4f910792de125323476ab547ff471b6be7ff64dd0ceef9dcf033847fb0246de</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经总结</title>
      <link href="/2023/01/30/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2023/01/30/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><blockquote><p>CSS 优先级顺序</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://vue3js.cn/interview/http/HTTP_HTTPS.html#%E4%B8%80%E3%80%81http">解析</a></div></blockquote></blockquote><h1 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h1><blockquote><p>JS 的基本数据类型</p></blockquote><blockquote><p>闭包的理解和举例使用</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://vue3js.cn/interview/JavaScript/closure.html">解析</a></div></blockquote></blockquote><blockquote><p>正则表达式（手写正则匹配手机号&#x2F;邮箱）</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://blog.csdn.net/weixin_45568677/article/details/115560186">解析</a></div></blockquote></blockquote><blockquote><p>日期格式化（实现一个 format(new Date(), ‘YYYY-MM-DD’)函数）</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://blog.csdn.net/wlijun_0808/article/details/123687001">解析</a></div></blockquote></blockquote><blockquote><p>事件循环理解</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://vue3js.cn/interview/JavaScript/event_loop.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88">解析</a></div></blockquote></blockquote><blockquote><p>箭头函数和普通函数的 this 的区别。</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://vue3js.cn/interview/http/status.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88">解析</a></div></blockquote></blockquote><blockquote><p>什么是防抖和节流？有什么区别？如何实现？</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://vue3js.cn/interview/vue/vue3_vue2.html#%E4%B8%80%E3%80%81vue3%E4%BB%8B%E7%BB%8D">解析</a></div></blockquote></blockquote><blockquote><p>什么是跨域，怎么解决？</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://vue3js.cn/interview/vue/cors.html#%E4%B8%80%E3%80%81%E8%B7%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88">解析</a></div></blockquote></blockquote><blockquote><p>原型和构造函数相关</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://vue3js.cn/interview/JavaScript/prototype.html#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93">解析</a></div></blockquote></blockquote><blockquote><p>this 指向</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://vue3js.cn/interview/JavaScript/this.html#%E4%B8%80%E3%80%81%E5%AE%9A%E4%B9%89">解析</a></div></blockquote></blockquote><blockquote><p>typeof null，typeof undefined</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://juejin.cn/post/7176644710847479869#heading-5">解析</a></div></blockquote></blockquote><blockquote><p>var const let ？变量提升？原因？</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://vue3js.cn/interview/es6/var_let_const.html#%E4%B8%80%E3%80%81var">解析</a></div></blockquote></blockquote><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><blockquote><p>Vue 的生命周期</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://vue3js.cn/interview/vue/lifecycle.html#%E4%B8%80%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E4%BB%80%E4%B9%88">解析</a></div></blockquote></blockquote><blockquote><p>Vue Router 的模式、实现原理</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://blog.csdn.net/Edasi/article/details/107980498">解析</a></div></blockquote></blockquote><blockquote><p>Vue2 和 3 的区别</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://vue3js.cn/interview/vue/vue3_vue2.html#%E4%B8%80%E3%80%81vue3%E4%BB%8B%E7%BB%8D">解析</a></div></blockquote></blockquote><blockquote><p>keep-alive</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://vue3js.cn/interview/vue/keepalive.html#%E4%B8%80%E3%80%81keep-alive-%E6%98%AF%E4%BB%80%E4%B9%88">解析</a></div></blockquote></blockquote><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><blockquote><p>TCP 队首阻塞、七层网络模型</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://blog.csdn.net/fesfsefgs/article/details/108297742">解析</a></div></blockquote></blockquote><blockquote><p>SSR 应用的优点，有什么需要注意的</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://vue3js.cn/interview/vue/ssr.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88">解析</a></div></blockquote></blockquote><blockquote><p>http 状态码</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://vue3js.cn/interview/http/status.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88">解析</a></div></blockquote></blockquote><blockquote><p>tcp 和 udp</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://vue3js.cn/interview/http/UDP_TCP.html#%E4%B8%80%E3%80%81udp">解析</a></div></blockquote></blockquote><blockquote><p>http</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://vue3js.cn/interview/http/HTTP_HTTPS.html#%E4%B8%80%E3%80%81http">解析</a></div></blockquote></blockquote><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><blockquote><p>进程和线程</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://vue3js.cn/interview/linux/thread_process.html#%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B">解析</a></div></blockquote></blockquote><h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><blockquote><p>剑指 Offer 55 - I. 二叉树的深度</p><blockquote><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/">解析</a></div></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue导图</title>
      <link href="/2023/01/10/Vue%E5%AF%BC%E5%9B%BE/"/>
      <url>/2023/01/10/Vue%E5%AF%BC%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>模板语法</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>插值</p></div></div><div class='timeline-item-content'><ol><li>Mustache 标签 &#x3D;&gt; v-once 指令</li><li>原始 HTML &#x3D;&gt; v-html 指令</li><li>Attribute &#x3D;&gt; v-bind 指令</li></ol></div></div></div><div class="timeline red"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>计算属性和侦听器</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>计算属性</p></div></div><div class='timeline-item-content'><ol><li>计算属性 相当于给 Mustache 标签做了相应的功能</li><li>计算属性缓存 vs 方法<br>&#x3D;&gt; 两种方式的最终结果确实是完全相同的<br>&#x3D;&gt; 最明显的不同 就是调用的时候，methods 要加上（）<br><span class='p red'>不同的是计算属性是基于它们的响应式依赖(相关依赖发生改变时才会重新取值)进行缓存的</span></li><li>计算属性 vs 侦听属性</li><li>计算属性的 setter<br>&#x3D;&gt;computed 属性默认只有 getter,也可加 setter，setter 会被调用，也会更新</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>监听属性</p></div></div><div class='timeline-item-content'><p>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的</p><p>（例子）使用 watch 实现计数器,千米与米之间的换算</p></div></div></div><div class="timeline green"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>样式绑定</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>class 属性绑定</p></div></div><div class='timeline-item-content'><p>&#x3D;&gt; 通过使用 v-bind 绑定一个值，判断其真假来是否渲染该样式</p><ol><li>对象 &#x3D;&gt; 通过 data 赋值真假</li><li>数组 &#x3D;&gt; 通过 data 赋值真假</li><li>组件 &#x3D;&gt; 通过 data 赋值真假，自带样式不会被覆盖</li></ol></div></div></div><div class="timeline yello"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>条件渲染</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>v-if vs v-show</p></div></div><div class='timeline-item-content'><p>v-if &#x3D;&gt; 1. 它才是真正的条件渲染，在切换过程中 事件监听器和子组件 会被适当的<span class='p red'>销毁和重建</span> 2. 也有惰性，如果为假，就啥都不做，不浪费资源 3. 有频繁的切换开销<br>v-show &#x3D;&gt; 1. <span class='p green'>只渲染一次</span>，然后根据条件看是否显示 2. 只会有初始渲染开销</p></div></div></div><div class="timeline pink"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>列表渲染</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>维护状态</p></div></div><div class='timeline-item-content'><p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key attribute</p><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://v2.cn.vuejs.org/v2/api/#key">key</a></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>v-for 与 v-if 一同使用</p></div></div><div class='timeline-item-content'><p>不推荐在同一元素上使用 v-if 和 v-for</p><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://v2.cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7%E5%BF%85%E8%A6%81">避免 v-if 和 v-for 用在一起</a></div></div></div></div><div class="timeline gold"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>列表渲染</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>修饰符</p></div></div><div class='timeline-item-content'><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://v2.cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6">事件修饰符</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://v2.cn.vuejs.org/v2/guide/events.html#%E7%B3%BB%E7%BB%9F%E4%BF%AE%E9%A5%B0%E9%94%AE">系统修饰键</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://v2.cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6">按键修饰符</a></div></div></div></div><div class="timeline olive"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>表单输入绑定</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>基础</p></div></div><div class='timeline-item-content'><p>&#x3D;&gt; 通过使用 v-model 指令在表单 &lt; input &gt;、&lt; textarea &gt; 及 &lt; select &gt; 元素上创建双向数据绑定</p><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://v2.cn.vuejs.org/v2/guide/forms.html#%E4%BF%AE%E9%A5%B0%E7%AC%A6">修饰符</a></div></div></div></div><div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>组件</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>基础</p></div></div><div class='timeline-item-content'><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://v2.cn.vuejs.org/v2/guide/components.html#%E7%BB%84%E4%BB%B6%E7%9A%84%E5%A4%8D%E7%94%A8">组件复用实例</a></div></div></div></div><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>组件注册</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>全局注册</p></div></div><div class='timeline-item-content'><ol><li>全局注册所有的组件意味着,造成了用户下载的 JavaScript 的无谓的增加。</li><li>Vue.component(‘my-component-name’, {<br>&#x2F;&#x2F; … 选项 …<br>})</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>局部注册</p></div></div><div class='timeline-item-content'><ol><li><p>局部注册的组件在其子组件中不可用</p></li><li><p>如果你希望 ComponentA 在 ComponentB 中可用，则你需要这样写：<br>import ComponentA from ‘.&#x2F;ComponentA.vue’</p><p>export default {<br>components: {<br>ComponentA<br>},<br>&#x2F;&#x2F; …<br>}</p></li></ol></div></div></div><div class="timeline red"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>Prop</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>传递静态或动态 Prop</p></div></div><div class='timeline-item-content'><ol><li>通过使用 v-bind 可以动态赋值 &#x3D;&gt; 数字，布尔值，数组，对象</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>单向数据流</p></div></div><div class='timeline-item-content'><ol><li>父级 prop 的更新会向下流动到子组件中，但是反过来则不行</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>Prop 验证</p></div></div><div class='timeline-item-content'><p>可以为组件的 prop 指定验证要求，例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>禁用 Attribute 继承</p></div></div><div class='timeline-item-content'><p>可以在组件的选项中设置 inheritAttrs: false</p></div></div></div><div class="timeline green"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>动态组件 &amp; 异步组件</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>动态组件</p></div></div><div class='timeline-item-content'><ol><li>is attribute</li><li>&lt; keep-alive &gt;用法</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>异步组件</p></div></div><div class='timeline-item-content'><ol><li>运用resolve 回调</li><li>运用Promise</li></ol></div></div></div><h2 id="过渡-amp-动画"><a href="#过渡-amp-动画" class="headerlink" title="过渡 &amp; 动画"></a>过渡 &amp; 动画</h2><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>进入&#x2F;离开 &amp; 列表过渡</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>概述</p></div></div><div class='timeline-item-content'><ol><li>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果</li><li>在下列情形中，可以给任何元素和组件添加进入&#x2F;离开过渡:</li></ol><ul><li>条件渲染 (使用 v-if)</li><li>条件展示 (使用 v-show)</li><li>动态组件</li><li>组件根节点</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>单元素&#x2F;组件的过渡</p></div></div><div class='timeline-item-content'><ol><li>过渡的类名:<br><img src="https://v2.cn.vuejs.org/images/transition.png" alt="code"></li></ol></div></div></div><h2 id="可复用性-amp-组合"><a href="#可复用性-amp-组合" class="headerlink" title="可复用性 &amp; 组合"></a>可复用性 &amp; 组合</h2><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>混入</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>概述</p></div></div><div class='timeline-item-content'><ol><li>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>选项合并</p></div></div><div class='timeline-item-content'><ol><li>当组件和混入对象含有<span class='p red'>同名选项</span>时，这些选项将以恰当的方式进行“合并”。</li></ol><p>同名：<br>函数 &#x3D;&gt; 将函数化为数组，都调用，谁前谁调用</p><p>对象 &#x3D;&gt; 取组件的对象键值对</p></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue笔记</title>
      <link href="/2023/01/07/Vue%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/07/Vue%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h2><p>关于 Vue 组件化说法错误的是（ ）<br>A<br>所谓组件化，就是把页面拆分成多个组件 (component)，每个组件依赖的 CSS、JavaScript、模板、图片等资源放在一起开发和维护<br>B<br>组件是资源独立的，组件在系统内部可复用，但是组件和组件之间不可以嵌套<br>C<br>vue 的组件之间可以进行通信<br>D<br>组件化能提高开发效率，方便重复使用，简化调试步骤，提升项目可维护性，便于多人协同开发</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>组件是资源独立的，组件在系统内部可复用，而且组件和组件之间可以嵌套</p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://vue3js.cn/interview/vue/components_plugin.html#%E4%B8%80%E3%80%81%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88">组件</a></div>              </div>            </details><hr><p>下列关于 v-model 的说法，哪项是不正确的是（ ）<br>A<br>v-model 如果为不同元素绑定数据，则使用不同的元素 property， 并抛出不同的事件<br>B<br>v-model 本质上是语法糖，它负责监听用户的输入事件以更新数据<br>C<br>v-model 是内置指令，不能用在自定义组件上<br>D<br>对 input 使用 v-model，实际上是指定其 :value 和 input 事件</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>vue2.2+版本新增了一个功能，可以在自定义组件上使用 v-model 实现双向绑定</p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://v2.cn.vuejs.org/v2/api/#v-model">v-model</a></div>              </div>            </details><hr><p>以下不是 vue 内置指令的是（ ）<br>A<br>v-html<br>B<br>v-on<br>C<br>v-for<br>D<br>v-hidden</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>没有 v-hidden 指令</p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://v2.cn.vuejs.org/v2/api/#v-html">v-html</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://v2.cn.vuejs.org/v2/api/#v-on">v-on</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://v2.cn.vuejs.org/v2/api/#v-for">v-for</a></div>              </div>            </details><hr><p>下列关于v-for说法错误的是（   ）<br>A<br>v-for指令基于一个数组来渲染一个列表<br>B<br>v-for指令需要使用item in items形式的特殊语法，其中items是源数据数组，而item则是被迭代的数组元素的别名<br>C<br>不可以用v-for来遍历一个对象的property<br>D<br>v-for在使用的时候最好添加key，且key最好不是索引</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>可以用v-for来遍历一个对象的property</p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://v2.cn.vuejs.org/v2/api/#v-for">v-for</a></div>              </div>            </details><hr>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>javascript笔记</title>
      <link href="/2023/01/04/javascript%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/04/javascript%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h2><p>在 HTML 页面中创建一个按钮，当点击该按钮时调用已定义的 compute 函数 。下列选项中，符合要求的一项是()</p><p>A. &lt; input onBlur&#x3D;”compute()” &gt;<br>B. &lt; input onFocus&#x3D;”compute()”&gt;<br>C. &lt; input onClick&#x3D;”function compute()” &gt;<br>D. &lt; input onClick&#x3D;”compute()” &gt;</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>选 D。考察的是 HTML DOM 事件允许 Javascript 在 HTML 文档元素中注册不同事件处理程序。<br>A 选择中的 onBlur 表示元素失去焦点时触发。所以 A 错误。<br>B 选择中的 onFocus 表示元素获取焦点时触发。所以 B 错误。<br>C 选择中的 onClick&#x3D;”function compute()”，function 关键字不属于对函数的调用，而是对函数的声明。所以 C 错误</p>              </div>            </details><hr><p>执行以下程序，下列说法中，正确的是（）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var arr = new Array(3); ...①<br><br>arr[0] = 1;<br><br>arr.b = 0;<br><br>console.log(arr.length); ...②<br><br>arr.forEach(value=>&#123;<br><br>        console.log(value); ...③<br><br>&#125;)<br><br>for(var i in arr)&#123;<br><br>      console.log(arr[i]); ...④<br><br>&#125;<br></code></pre></td></tr></table></figure><p>A<br>① 式创建一个长度为 3 的数组<br>B<br>② 式输出结果为 4<br>C<br>③ 式输出结果为 1 0<br>D<br>④ 式输出结果为 1</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>A 选项，当 new Array()括号内只有一个参数时，该参数表示数组的长度，A 正确；<br>B 选项，数组的长度仍为 3，这是因为 arr.b &#x3D; 0;实际上是为变量 arr 赋予属性 b，该属性不是数组元素，所以 arr.length 值不变，仍为 3；<br>C 选项，forEach 函数只遍历数组元素，由于 arr 数组的数组元素只有 1，因此输出结果为 1；<br>D 选项，for…in…会遍历数组以及数组的可枚举属性，因此输出结果为 1 0</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>数组</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>数组方法</p>            </div>              </div>            </details><hr><p>删除 arr 数组中的第 i 个元素的最好做法是？</p><p>①<br>arr.splice(i-1,1)<br>②<br>arr.slice(0,n).concat(arr.slice(n+1,arr.length));<br>③<br>Array.prototype.remove &#x3D; function(dx)　 {　　<br>if (isNaN(dx) || dx &gt; this.length) {<br>return false;<br>}　　<br>for (var i &#x3D; 0,<br>n &#x3D; 0; i &lt; this.length; i++)　　 {　　　　<br>if (this[i] !&#x3D; this[dx])　　　 {　　　　　　 this[n++] &#x3D; this[i]　　　　<br>}　　<br>}　　 this.length -&#x3D; 1 　<br>}<br>④<br>for (var i &#x3D; 0,<br>n &#x3D; 0; i &lt; this.length; i++)　　 {　　　　<br>if (this[i] !&#x3D; this[dx])　　　　 {　　　　　 this[n++] &#x3D; this[i]　　　　<br>}　　<br>}</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <blockquote><blockquote><p>arrayObject.splice(index,howmany,item1,…..,itemX)</p></blockquote></blockquote><p>splice() 方法向&#x2F;从数组中添加&#x2F;删除项目，然后返回被删除的项目。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>index</td><td>必需。整数，规定添加&#x2F;删除项目的位置，使用负数可从数组结尾处规定位置。</td></tr><tr><td>howmany</td><td>必需。要删除的项目数量。如果设置为 0，则不会删除项目。</td></tr><tr><td>item1, …, itemX</td><td>可选。向数组添加的新项目。</td></tr></tbody></table><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>数组方法</p>            </div>              </div>            </details><hr><p>以下代码中,给 class 为 test 的 div 对象设置红色背景的正确 js 代码为( )</p><div class="test"></div><p>A<br>document.getElementsByClassName(“test”).style.backgroundColor&#x3D;”red”;<br>B<br>document.getElementsByClassName(“test”)[0].style.backgroundColor&#x3D;”red”;<br>C<br>document.getElementsByClassName(“test”)[0].style.background-color&#x3D;”red”;<br>D<br>document.getElementsByClassName(“test”).style.background-color&#x3D;”red”;</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>document.getElementsByClassName 返回一个数组，<br>需要挨个遍历数组，然后再 .style.backgroundColor &#x3D; ‘red’</p><p>document.getElementsByClassName()返回一个数组，由于该页面仅有一个 class&#x3D;test 的元素，所以通过[0]选择到该元素。通过 js 选择 css 属性时，属性都为驼峰的形式，所以为 style.backgroundColor</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>DOM</p>            </div>              </div>            </details><hr><p>代码 var foo &#x3D; “10”+3-“1”;console.log(foo);执行后，foo 的值为( )<br>A<br>“102”<br>B<br>102<br>C<br>12<br>D<br>“12”</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>① 为任意的数据类型+””即可将其转换成 String 字符串类型，这是一种隐式类型转换，由浏览器自动完成，实际上也是调用 String()函数。</p><p>② 为任意的数据类型 -0 即可将其转换成 Number 数值类型。<br>“103”-“1”&#x3D;102 答案 B</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>字符串和数字</p>            </div>              </div>            </details><hr><p>执行以下程序，输出结果为（）</p><p>var uname &#x3D; “window”;</p><p>var object &#x3D; {</p><pre><code>        uname :&quot;object&quot;,        fun:function()&#123;            console.log(this.uname);            return function()&#123;               console.log(this.uname);            &#125;        &#125;</code></pre><p>}</p><p>object.fun()();</p><p>A<br>object</p><p>B<br>window</p><p>C<br>object window</p><p>D<br>window object</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>object.fun()()等效于 var fn &#x3D; object.fun(); fn();实际上是调用函数两次，第一次是调用 object 对象的 fun 函数，第二次是调用 fun 函数的返回函数。第一次调用 fun 函数时，this 指向上一级对象，即 object 对象，因此输出对象 object 的 uname 属性值 object,第二次调用的返回函数，其 this 指向 window 对象，这是因为匿名函数具有全局性，匿名函数的 this 指向 window 对象，因此输出结果为 window 对象的 uname 属性值 window。</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>对象</p>            </div>              </div>            </details><hr><p>以下结语句中，返回 true 的是？<br>A<br>!![]<br>B<br>1&#x3D;&#x3D;&#x3D;’1’<br>C<br>null&#x3D;&#x3D;&#x3D;undefined<br>D<br>!!’’</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>JavaScript 有五个基本类型：number、string、null 和 undefined。其中 null 和 undefined 以外，其他三个具有所谓的包装对象，可以通过内置构造函数 Number()、String()、Boolean()创建包装对象。 选项 A，javascript 中[]转化为布尔值为 true，即 Boolean([])返回 true，加上两个非符号返回仍为 true。 选项 B，&#x3D;&#x3D;&#x3D;表示等同符，当两边值类型相同时直接比较值，若类型不同返回 false。int 类型和 char 类型不同所以返回 false。 选项 C，null 表示空值，undefined 未定义，直接返回 false 选项 D，Boolean(‘’)返回 false，加上两个非符号，最终结果为 false。</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>Javascript基础</p>            </div>              </div>            </details><hr><p>请问以下 JS 代码最后输出的 len 值是多少？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var len = 117;<br><br>let func = &#123;<br><br>len: 935,<br>showLen: function() &#123;<br><br>    console.log(this.len);<br><br>&#125;,<br>show: function() &#123;<br><br>    (function(cb) &#123;<br><br>      cb();<br>    &#125;)(this.showLen)<br><br>&#125;<br>&#125;<br>func.show();<br></code></pre></td></tr></table></figure><p>A<br>117<br>B<br>935<br>C<br>undefined<br>D<br>null</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext"><br>// 在 JavaScript 的函数中，this 始终指向调用者的上下文环境<br>var len = 117 // 5. 全局作用域中使用 var 定义的变量默认会成为 window 的属性，及 window.len<br><br>let func = &#123;<br><br>len: 935,<br>showLen: function () &#123;<br><br>    console.log(this.len) // 4. this 此时指向的是 window，所以相当于打印 window.len<br><br>&#125;,<br>show: function () &#123;<br><br>    (function (cb) &#123;<br><br>      cb() // 3. cb 相当于 cb.call() 默认没有传入上下文环境时 this 指向全局的 window 对象<br>    &#125;)(this.showLen) // 2. this 是 func 所以传入的是上面定义的 showLen 函数<br><br>&#125;<br>&#125;<br><br>func.show() // 1. 相当于 func.show.call(func)，此时 this 是 func<br>&#125;;<br></code></pre></td></tr></table></figure><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>立即执行函数</p>            </div>              </div>            </details><h2 id="1-5"><a href="#1-5" class="headerlink" title="1.5"></a>1.5</h2><p>执行以下程序，下列选项中，说法错误的是（）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">class Phone&#123;<br><br>  constructor(brand)&#123;<br>    <br>    this.brand = brand;<br>&#125;<br>  call()&#123;&#125;...①<br>&#125;<br>function playGame()&#123;console.log("我可以打游戏")&#125;;<br>function photo()&#123;console.log("我可以拍照")&#125;;<br>console.log(typeof Phone);...②<br>var p = new Phone(&#x27;华为&#x27;);<br>console.log(p.brand);...③<br></code></pre></td></tr></table></figure><p>A<br>①式的call方法是定义在类Phone的prototype对象上</p><p>B<br>②式输出结果为Object</p><p>C<br>③式输出结果为华为</p><p>D<br>若想一次性给类添加playGame和photo两个实例方法，可以使用Object.assign(Phone.prototype,{playGame,photo})</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>类的所有实例方法均定义在类的原型对象上，因此，在类内定义的实例方法和在类的原型对象上定义方法是等价的，call()是实例方法，故A选项说法正确，不符合题意；<br>类的本质是函数，实际上，ES6中的类可以视为ES5中构造函数的另一种写法，所以②式的输出结果为function而不是Object，B选项说法错误，符合题意；<br>p为类的实例对象，该对象有一个属性brand，属性值为华为，C选项说法正确，不符合题意；<br>Object.assign(target, source)可将source源对象所有可枚举的属性（或方法）分配给target对象，所以可以使用Object.assign(Phone.prototype,{playGame,photo})为类一次性添加playGame和photo两个实例方法，D选项说法正确，不符合题意。</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>类</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>对象</p>            </div>              </div>            </details><hr><p>执行下列选项的程序，输出结果不是Window对象的是（）</p><p>A<br>setTimeout(function(){</p><p>console.log(this);<br>},1000);<br>B<br>function Star(){</p><p>console.log(this);</p><p>}</p><p>new Star();</p><p>C<br>var o &#x3D; {</p><p>sayHi:()&#x3D;&gt;{</p><p>console.log(this);</p><p>}<br>}<br>o.sayHi();</p><p>D<br>(function(){</p><p>console.log(this);</p><p>}());</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>在setTimeout()定时器中，this指向Window对象，A选项不符合题意；<br>通过new Star()来调用Star函数，由于使用new绑定，Star函数内部的this指向new创建的实例，而非Window对象，B选项符合题意；<br>箭头函数不会与this进行绑定，其this指向取决于该箭头函数同级作用域的this指向，又由于对象不能形成自己的作用域，因此其作用域为全局作用域，this指向Window对象，C选项不符合题意；<br>D选项，立即执行函数的this指向Window对象，D选项不符合题意。</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>立即执行函数</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>定时器</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>箭头函数</p>            </div>              </div>            </details><hr><p>下列表达式中，返回值为true的是（）</p><p>①Object.is(NaN,NaN)</p><p>②Object.is(+0,-0)</p><p>③NaN &#x3D;&#x3D;&#x3D; NaN</p><p>④+0 &#x3D;&#x3D;&#x3D; -0</p><p>A<br>①④</p><p>B<br>①③</p><p>C<br>②③</p><p>D<br>②④</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>Object.is()与&#x3D;&#x3D;&#x3D;都是判断两个数是否严格相等。它们的区别主要在NaN自身和+0与-0的判断。<br>对于NaN自身的判断，Object.is(NaN,NaN)的返回结果为true，而NaN&#x3D;&#x3D;&#x3D;NaN的返回结果为false；<br>对于+0、-0的判断，Object.is(+0,-0)的返回结果为false，而+0&#x3D;&#x3D;&#x3D;-0的返回结果为true，故A选项正确。</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>JavaScript基础</p>            </div>              </div>            </details><hr><p>console.log(([])?true:false);<br>console.log(([]&#x3D;&#x3D;false?true:false));<br>console.log(({}&#x3D;&#x3D;false)?true:false) </p><p>上面这段代码运行后得到的结果分别是什么？</p><p>A<br>false true true<br>B<br>true true true<br>C<br>true false true<br>D<br>true true false</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>《JavaScript权威指南》的部分相关知识点 “&#x3D;&#x3D;”运算符（两个操作数的类型不相同时） 如果一个值是null，另一个值是undefined，则它们相等 如果一个值是数字，另一个值是字符串，先将字符串转换为数学，然后使用转换后的值进行比较。 如果其中一个值是true，则将其转换为1再进行比较。如果其中的一个值是false，则将其转换为0再进行比较。 如果一个值是对象，另一个值是数字或字符串，则将对象转换为原始值，再进行比较。 对象到数字的转换 如果对象具有valueOf()方法，后者返回一个原始值，则JavaScript将这个原始值转换为数字（如果需要的话）并返回一个数字。 否则，如果对象具有toString()方法，后者返回一个原始值，则JavaScript将其转换并返回。（对象的toString()方法返回一个字符串直接量（作者所说的原始值），JavaScript将这个字符串转换为数字类型，并返回这个数字）。 否则，JavaScript抛出一个类型错误异常。 空数组转换为数字0 数组继承了默认的valueOf()方法，这个方法返回一个对象而不是一个原始值，因此，数组到数学的转换则调用toString()方法。空数组转换为空字符串，空字符串转换为数字0.</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>JavaScript基础</p>            </div>              </div>            </details><hr><p>下面一段JavaScript代码的运行结果是</p><p>var a,b;<br>(function(){<br>    alert(a);<br>    alert(b);<br>    var a&#x3D;b&#x3D;3;<br>    alert(a);<br>    alert(b);<br>})();<br>alert(a);<br>alert(b);</p><p>A<br>undefined，undefined，3,3，undefined，3<br>B<br>undefined，undefined，3,3，undefined，undefined<br>C<br>0，0，3,3，undefined，undefined<br>D<br>undefined，undefined，3,3，0，0</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>这道题中最重要的代码行是：var a&#x3D;b&#x3D;3;<br>赋值是从右往左进行的，也就是说这一行先执行b&#x3D;3，这时候b就是全局变量了，没有被var过。然后是var a &#x3D; b；<br>a被声明了，是局部变量。</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>作用域</p>            </div>              </div>            </details><hr><p>已知arr &#x3D; [1,2,NaN,1,4,2,NaN]，现为输出arr的不重复元素（重复元素只输出一次），则下列程序中的①处，可以作为判断条件的是（）</p><p>var newArr &#x3D; [];<br>for(var i &#x3D; 0 ;i&lt;arr.length;i++){<br>  if(①){<br>    newArr.push(arr[i]);<br>  }<br>}<br>console.log(newArr);</p><p>A<br>newArr.indexOf(arr[i]) &#x3D;&#x3D; -1</p><p>B<br>!newArr.indexOf(arr[i]) &#x3D;&#x3D; -1</p><p>C<br>newArr.includes(arr[i])</p><p>D<br>!newArr.includes(arr[i])</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>indexOf()方法与includes()方法的一个重要区别在于indexOf()并不能判断数组的NaN元素，换句话说，不管数组arr是否有NaN元素，arr.indexOf(NaN)返回值都是-1，所以AB选项不能对NaN进行去重，不符合题意；<br>如果newArr数组不含有arr数组的某个元素，就应该把该元素添加到newArr数组中，如果含有，则不能添加，这样才能达到去重的目的，即newArr.includes(arr[i])返回值为false时，就应该执行if内的语句，所以应该使用“!”对条件取反，D选项符合题意，C选项不符合题意。</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>数组方法</p>            </div>              </div>            </details><hr><p>执行以下程序，当用户在prompt输入框中输入0时，输出结果为（）</p><p>var num &#x3D; prompt(‘请输入分母:’)<br>try{<br>  console.log(‘a’);<br>  value &#x3D; 0 &#x2F; num;<br>  console.log(‘b’);<br>}<br>catch(e){<br>  console.log(‘c’);<br>}<br>finally{<br>  console.log(‘d’);<br>}</p><p>A<br>a c d</p><p>B<br>a b d</p><p>C<br>a b c d</p><p>D<br>a b c</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>当用户输入0时，会导致分母为0。虽然在绝大多数编程语言中，0是不能作为分母，但在js中，0是可以作分母的，0&#x2F;0的结果为NaN，并不会抛出异常，因此会执行try块中所有代码，输出a b，并且由于没有异常的发生不会执行catch块，不管有没有异常，finally块都会执行的，因此最终输出结果为a b d，B选项正确。</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>错误处理</p>            </div>              </div>            </details><hr><p>在JavaScript中，以下哪些是原始值（primitive value）？<br>A<br>”3”<br>B<br>10<br>C<br>null<br>D<br>[1]</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>ECMAScript中，变量可以存放两种类型的值，即原始值和引用值。<br>原始值是存储在栈中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。<br>引用值是存储在堆中的对象，也就是说，存储在变量处的值是一个指针，指向存储对象的内存处。<br>ECMAScript中有5种原始类型，即undefined、null、number、string、boolean。<br>选项中的值分别是：string、number、null，而最后一个是数组，数组是一个对象，所以是引用值。</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>变量</p>            </div>              </div>            </details><hr><p>语句var arr&#x3D;[a,b,c,d];执行后，数组arr中每项都是一个整数，下面得到其中最大整数语句正确的是哪几项？<br>A<br>Math.max(arr)<br>B<br>Math.max(arr[0], arr[1], arr[2], arr[3])<br>C<br>Math.max.call(Math, arr[0], arr[1], arr[2], arr[3])<br>D<br>Math.max.apply(Math,arr)</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>Math.max(args…)传入参数是任意数量的值<br>A  传入数组,所以错误<br>B  可以<br>C  Function.call()可以传入任意多个参数,C正确<br>D  Function.apply()第二个参数以数组形式传递,D正确</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>call、apply 区别</p>            </div>              </div>            </details><hr><p>以下哪些表达式的结果为true（）<br>A<br>undefined &#x3D;&#x3D; null<br>B<br>isNaN(“100”)<br>C<br>parseInt(“1a”) &#x3D;&#x3D;&#x3D; 1<br>D<br>[] instanceof Array</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>&#x2F;&#x2F; 1. isNaN()函数用来判断一个数是否是NaN;<br>            &#x2F;&#x2F; 只有一个值是NaN或者能被转换为NaN的时候才返回true<br>            console.log(isNaN(‘e’));&#x2F;&#x2F;true,因为e可以被转换为NaN<br>            console.log(isNaN(‘11’));&#x2F;&#x2F;false,因为字符串可以被转换为数字,不能被转为NaN<br>            console.log(isNaN(null));&#x2F;&#x2F;false,因为null可以被转换为0,不能被转为NaN<br>            console.log(isNaN(NaN));&#x2F;&#x2F; true,NaN返回true</p><pre><code>        // 2. parseInt(string,raix)函数有两个参数        // 2.1 注意:string字符串只会被解析从第一个字符开始直到不是数字的字符部分        console.log(parseInt(&#39;223&#39;));//223        // 2.2 当字符串中间存在非数字,那么就只解析前面是数字的部分字符        console.log(parseInt(&#39;22e3&#39;));//22        // 2.3 如果字符串中第一个字符就不是数字,那么返回NaN         console.log(parseInt(&#39;e21&#39;));//NaN                // 对于parseInt()函数还有一个易考点,就是利用数组的下标,还记得parseInt()函数的第二个参数吗？        // 2.4 parseInt()函数的第二个参数指的就是进制,这个参数小于2或者大于36的时候,都会返回NaN         console.log(parseInt(1,1));//NaN ,因为第二个参数是1表示1进制&lt;2,所以错误        console.log(parseInt(1,2));//1,因为表示二进制 =2,在范围内        // 2.5 我们一般都是省略这个参数的,这个时候就是默认为10进制        console.log(parseInt(99));//99        // 2.6 我们第二个参数使用0的时候也是使用十进制        console.log(parseInt(99,0));//99        // 2.7 如果第一个参数前缀使用0x/0X则表示使用16进制        console.log(parseInt(0x99));//153=16*9+9        console.log(parseInt(0x99,10));//如果第一个参数使用了0x表示十六进制,那么第二个参数设置了值也无效                // 2.8 看一个实例,对于数组        var arr=[1,2,3,2,5];        console.log(arr.map(parseInt));//[1, NaN, NaN, 2, NaN]        // arr.map方法就是对于数组arr里面的每一项都去使用方法里面的函数,最后返回新数组        // 因为map方***有索引,所以实际上就是         parseInt(1,0);//1,因为0表示十进制        parseInt(2,1);//1进制&lt;2，所以错啦!        parseInt(3,2);// 2进制,但是3不在0——2范围内(3应该改为11),所以不符合2进制要求        parseInt(2,3);//符合,因为三进制是0-3,而2在范围内        parseInt(5,4);//4进制不包括5,所以NaN</code></pre><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>JavaScript基础</p>            </div>              </div>            </details><hr><p>以下哪些语句触发了隐式的类型转换？<br>A<br>parseInt(12.34, 10)<br>B<br>0 ? 1 : 2<br>C<br>2e1 * 0xaa<br>D<br>1 + ‘1’</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>parseInt() 函数可解析一个字符串，并返回一个整数。<br>所以说，number类型的12.34发生隐式转换为string。<br>三元运算符，会判断?前的表达式为true或者false。所以number类型的0发生了隐式转换为boolean。<br>+运算发生了字符串的隐式转化。原本number类型的1，和string类型的’1’进行了+运算，连接了字符串。返回’11’。<br>C选项：<br>e是js里面指数的一种表示形式。也就是10的多少次方。<br>2e1 等价于 2 *（10^1） &#x3D; 20<br>2e2 等价于 2 <em>（10^2）&#x3D; 200<br>0xaa是16进制的表示方法。相当于十进制的170。<br>这里都是number类型，发生了数字的乘法运算：20</em>170，没有发生类型转换。</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>JavaScript基础</p>            </div>              </div>            </details><hr><p>如下代码片段的运行结果是</p><p>var obj &#x3D;{a:1,b:function () {alert(this.a)}};<br>var fun &#x3D;obj.b;<br>fun();</p><p>A<br>弹出a<br>B<br>弹出1<br>C<br>弹出undefined<br>D<br>什么也看不到</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>var b &#x3D; function(){ alert(this.a); }, obj &#x3D; { a:1, b:b &#x2F;&#x2F; 把函数独立出来 }; var fun &#x3D; obj.b;&#x2F;&#x2F; 存储的是内存中的地址 fun(); 答案：C 虽然fun是obj.b的一个引用，但是实际上，它引用的是b函数本身，因此此时的fun()其实 是一个不带任何修饰的函数调用，所以this指向window。</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>作用域</p>            </div>              </div>            </details><hr><p>下列哪个方法不能改变自身数组？<br>A<br>splice<br>B<br>concat<br>C<br>sort<br>D<br>pop</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>pop方法：用于删除并返回数组的最后一个元素，把数组长度减1，并且返回它删除的元素的值。如果数组已经为空，则pop()不改变数组，并返回undefined值。</p><p>splice方法：向&#x2F;从数组中添加&#x2F;删除项目，然后返回被删除的项目，该方法会改变原始数组。</p><p>sort方法：用于对数组的元素进行排序。返回对数组的引用。请注意，数组在原数组上进行排序，不生成副本。</p><p>concat方法： 用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。</p><p>综上所述，只有concat方法不会改变数组，故选B</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>数组方法</p>            </div>              </div>            </details><h2 id="1-23"><a href="#1-23" class="headerlink" title="1.23"></a>1.23</h2><hr><p>下面标签嵌套正确的是<br>A</p><ul><p>牛客网</p></ul>B<a href="#"><a href="#">牛客网</a></a>C<dl><li>牛客网</li></dl>D<ol><li>牛客网</li></ol><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>ul和li搭配为无序列表<br>ol和li搭配为有序列表</p><dl> 标签定义了定义列表（definition list）。<dl> 标签用于结合 <dt> （定义列表中的项目）和 <dd> （描述列表中的项目）。              </div>            </details><hr><p>下面哪条声明能固定背景图片（）<br>A<br>background-attachment:fixed;<br>B<br>background-attachment:scroll;<br>C<br>background-origin: initial;<br>D<br>background-clip: initial;</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>background-attachment设置背景图像是否固定或者随着页面的其余部分滚动。</p><p>scroll背景图片随着页面的滚动而滚动，这是默认的。<br>fixed背景图片不会随着页面的滚动而滚动。<br>local背景图片会随着元素内容的滚动而滚动。<br>initial设置该属性的默认值。 阅读关于 initial 内容<br>inherit指定 background-attachment 的设置应该从父元素继承。 阅读关于 inherit 内容</p>              </div>            </details><hr><p>以下关于盒子模型描述正确的是：<br>A<br>标准盒子模型中：盒子的总宽度 ＝ 左右margin + 左右border + 左右padding + width<br>B<br>IE盒子模型中：盒子总宽度 ＝ 左右margin + 左右border + width<br>C<br>标准盒子模型中：盒子的总宽度 ＝ 左右margin + 左右border + width<br>D<br>IE盒子模型中：盒子总宽度 ＝ width</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>一个盒子由四个部分组成：content、padding、border、margin</p><p>content，即实际内容，显示文本和图像</p><p>boreder，即边框，围绕元素内容的内边距的一条或多条线，由粗细、样式、颜色三部分组成</p><p>padding，即内边距，清除内容周围的区域，内边距是透明的，取值不能为负，受盒子的background属性影响</p><p>margin，即外边距，在元素外创建额外的空白，空白通常指不能放其他元素的区域</p><p>盒子总宽度 &#x3D; width + padding + border + margin;</p><p>盒子总高度 &#x3D; height + padding + border + margin</p>              </div>            </details><hr><p>下面哪个属性不会让 div 脱离文档流（normal flow）？<br>A<br>position: absolute;<br>B<br>position: fixed;<br>C<br>position: relative;<br>D<br>float: left;</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>absolute   生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。<br>fixed生成固定定位的元素，相对于浏览器窗口进行定位。<br>relative生成相对定位的元素，相对于其正常位置进行定位。<br>static默认值。没有定位，元素出现在正常的流中</p>              </div>            </details><hr><p>运行以下程序</p><script>     var m= 1, j = k = 0;     function add(n) {         return n = n+1; 　 }     y = add(m);     function add(n) {         return n = n + 3;     } z = add(m); </script> <p>y和z的最终结果为:<br>A<br>2,4<br>B<br>4,4<br>C<br>2,2<br>D<br>报异常</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>js里面没有函数重载的概念，在其他语言中（如java）java中，可以存在同名函数， 只要传入的参数数量或者类型不同即可。在js中，定义了两个同名函数后， 后面的函数会覆盖前面定义的函数。结合这道题来说，由于函数声明提升， 所以函数声明会提前，由于存在同名函数，后面的add函数将覆盖第一个add函数， 所以两次调用add()返回的值是相同的。也就是y,z都为4.</p>              </div>            </details><hr><p>(function() {<br>      var a &#x3D; b &#x3D; 5;<br>  })();<br>console.log(b);<br>console.log(a);<br>上面这段代码运行后的输出是:<br>A<br>5，5<br>B<br>undefined，undefined<br>C<br>5，undefined<br>D<br>5，Uncaught ReferenceError: a is not defined</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>该式子是从右往左，开始未声明吧b，所以是全局变量。a因为是局部变量，所以Uncaught ReferenceError: a is not defined</p>              </div>            </details><hr><p>下面哪些是HTML5 新增的表单元素？<br>A<br>datalist<br>B<br>optgroup<br>C<br>output<br>D<br>legend</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>HTML5 有以下新的表单元素:</p><p><datalist><input>标签定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。<br><keygen><keygen> 标签规定用于表单的密钥对生成器字段。<br><output><output> 标签定义不同类型的输出，比如脚本的输出。</p>              </div>            </details><hr><p>请选出所有的置换元素（）<br>A<br>img<br>B<br>input<br>C<br>textarea<br>D<br>select</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>我们对置换元素有一个专业定义：<br>一个内容不受CSS视觉格式化模型控制，CSS渲染模型并不考虑对此内容的渲染，且元素本身一般拥有固有尺寸（宽度，高度，宽高比）的元素，被称之为置换元素。</p><p>常见的置换元素：</p><p>img<br>input<br>textarea<br>select<br>object<br>iframe<br>canvas</p>              </div>            </details><hr><p>下列说法正确的是（）<br>A<br>display: none；不为被隐藏的对象保留其物理空间；<br>B<br>visibility:hidden;所占据的空间位置仍然存在,仅为视觉上的完全透明；<br>C<br>visibility:hidden;产生reflow和repaint(回流与重绘)；<br>D<br>visibility:hidden;与display: none;两者没有本质上的区别；</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>display: none和visibility:hidden的区别就是visibility:hidden会保留元素的空间</p><p>repaint(重绘) ，repaint发生更改时，元素的外观被改变，且在没有改变布局的情况下发生，如改变outline,visibility,background color，不会影响到dom结构渲染。</p><p>reflow(渲染)，与repaint区别就是他会影响到dom的结构渲染，同时他会触发repaint，他会改变他本身与所有父辈元素(祖先)，这种开销是非常昂贵的，导致性能下降是必然的，页面元素越多效果越明显。</p><p>所以display:none才会产生reflow</p><p>visibility:hidden只会出发repaint</p>              </div>            </details><h2 id="1-25"><a href="#1-25" class="headerlink" title="1.25"></a>1.25</h2><p>下列说法正确的是（）<br>A<br>样式文件的加载会阻塞脚本的执行<br>B<br>iframe 会阻塞主页面的 load 事件<br>C<br><audio>、<img> 中的资源下载会阻塞页面解析<br>D<br>页面文档完全加载并解析完毕之后会触发 DOMContentLoaded 事件<br>select</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>A.css加载不会阻塞dom树的解析<br>  css加载会阻塞dom树的渲染<br>  css加载会阻塞后面js的进行<br>B.对<br>C.会阻塞dom解析的资源有：<br>1.内联css<br>2.内联js<br>3.普通外联js<br>4.外联defer js<br>5.js之前的外联css<br>D.对</p>              </div>            </details><hr><p>下列说法错误的是（）<br>A<br>当前域的 cookie 都可以通过 js 在当前域下获取<br>B<br> JSONP 是 XMLHttpRequest 中的一种<br>C<br>同源策略是浏览器的安全策略<br>D<br>localStorage API 不支持设置过期时间</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>对于一些保密性较高的 cookie 后端可以通过设置 HttpOnly 标记 cookie 只能通过 http 传递，前端 js 无法读取，这样可以防范xss攻击。<br>JSONP 用的是 html 的 script 标签，xmlhttprequest 是浏览器内置的 HTTP 相关对象，两者不同。<br>JSONP 是一种无需考虑跨域问题即可传送 JSON 数据的方法。<br>JSONP 不使用 XMLHttpRequest 对象。<br>JSONP 使用 <script> 标签取而代之。</p>              </div>            </details><hr><p>下列说法正确的是（）<br>A<br>requestAnimationFrame(foo) 确保使浏览器在下一次重绘之前调用 foo 方法<br>B<br>在 addEventListener 的处理方法中使用 e.preventDefault() 可以阻止事件冒泡<br>C<br> 把 <script> 标签的引入放在文档末尾可以确保脚本下载和执行均在文档解析完成后发生<br>D<br>多个 <script> 标签使用 defer属性引入脚本时，可以确保脚本的执行是按照其被引入的顺序的</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。<br>e.stopPropagation()，阻止事件冒泡<br>所有<script>标签引进的 JavaScript 会按照他们引入的顺序依次被解析，在没有使用 defer 或者 async 的情况下，只有在解析完前面<script>元素中的代码之后，才会开始解析后面<script>元素中的代码。由于浏览器会先解析完不使用 defer 属性的<script>元素中的代码，然后再解析后面的内容，所以一般应该把<script>元素放在页面最后，即主要内容后面，</body>标签前面。<br>使用 defer 属性可以让脚本在文档完全呈现之后再执行，延迟脚本总是按照它们指定的顺序执行。<br>使用 async 属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。</p>              </div>            </details><hr><p>请根据下面的示例描述原型链与继承的关系并解释原因：<br>class A {}<br>class B extends A {}<br>const a = new A()<br>const b = new B()<br>a.proto ===<br>b.proto ===<br>B.proto ===<br>B.prototype.proto ===<br>b.proto.proto ===</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <div class="img-wrap"><div class="img-bg"><img class="img" src="https://img-blog.csdnimg.cn/9dda389ba3d3418eb7f16b3fef9f0bf8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZW13ag==,size_16,color_FFFFFF,t_70#pic_center" alt="关于原型 class 之间的原型继承"/></div><span class="image-caption">关于原型 class 之间的原型继承</span></div>              </div>            </details><hr><p>请表述以下代码的执行结果和原因：<br>setTimeout(function () {<br>    console.log(1);<br>}, 0);</p><p>new Promise(function execulor(resolve) {<br>    console.log(2);<br>    for (var i = 0; i < 10000; i += 1) {<br>        i == 9999 && resolve()<br>    }<br>    console.log(3);<br>}).then(function () {<br>    console.log(4);<br>})<br>console.log(5);</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>结果：<br>2<br>3<br>5<br>4<br>1</p><p>原因：</p><ol><li>setTimeout 是定时器，属于宏任务，会在本轮宏任务结束之后的下一轮宏任务出现，现在进入宏任务队列等待 。</li><li>Promise 执行，打印 2 。</li><li>i为9999时，执行resolve，promise的状态变为resolve，然后执行下一行代码，打印 3。</li><li>promise 的状态为resolved，所以 then 语句进入微任务队列中，在宏任务结束之前执行。</li><li>打印 5。</li><li>此时最后一行代码执行完毕，执行微任务，打印 4。</li><li>进入下一轮宏任务，打印 1。</li></ol>              </div>            </details><hr><p>ajax 的 readyState 有哪几个状态，含义分别是什么？</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>5 个状态，分别是 0-4<br>0: 还没调用open方法<br>1: 未调用send方法，也就是还没发送数据给服务器<br>2: 还没有接收到响应<br>3: 开始接收到了部分数据<br>4: 接收完成，数据可以在客户端使用了</p>              </div>            </details><hr><p>ajax 的 readyState 有哪几个状态，含义分别是什么？</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>5 个状态，分别是 0-4<br>0: 还没调用open方法<br>1: 未调用send方法，也就是还没发送数据给服务器<br>2: 还没有接收到响应<br>3: 开始接收到了部分数据<br>4: 接收完成，数据可以在客户端使用了</p>              </div>            </details><hr><p>JavaScript 严格模式下有哪些不同？</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>1.严格模式对 JavaScript 的语法和行为，都做了一些改变。<br>严格模式下，变量必须先声明再使用，严禁删除已经声明变量。<br>严格模式下，预编译时 this 为 undefined。<br>严格模式下，不支持arguments、caller、callee、with。<br>严格模式下，在函数内部对修改参数不会反映到 arguments 中，淘汰了 arguments.callee 和 arguments.caller， 抛弃 with 语句。<br>严格模式下，不可在 if 内部声明函数<br>严格模式下，拒绝重复的属性和参数。<br>严格模式下，局部的this必须被赋值、赋值什么就是什么。</p><ol start="2"><li>严格模式下 this 指向问题<br>① 以前在全局作用域函数中的 this 指向 window 对象。</li></ol><p>② 严格模式下全局作用域中函数中的 this 是 undefined。</p><p>③ 以前构造函数不加 new 也可以调用，当普通函数，this 指向全局对象。</p><p>④ 严格模式下，如果构造函数不加 new 调用， this 指向的是 undefined ，如果给他赋值则会报错 。</p>              </div>            </details><hr><p>请给出下列代码的输出：<br>null == undefined<br>typeof NaN;<br>typeof Function;<br>typeof Object;<br>typeof {};<br>'a' + 1;<br>'a' - 1;<br>Function instanceof Object;<br>Object instanceof Function;</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>console.log(null &#x3D;&#x3D; undefined);  &#x2F;&#x2F; true<br>console.log(typeof NaN);    &#x2F;&#x2F; ‘number’<br>console.log(typeof Function);  &#x2F;&#x2F; ‘function’<br>console.log(typeof Object);    &#x2F;&#x2F; ‘function’<br>console.log(typeof {});   &#x2F;&#x2F; ‘object’<br>console.log(‘a’ + 1);   &#x2F;&#x2F; ‘a1’<br>console.log(‘a’ - 1);   &#x2F;&#x2F; NaN<br>console.log(Function instanceof Object);  &#x2F;&#x2F; true<br>console.log(Object instanceof Function);  &#x2F;&#x2F; true</p>              </div>            </details><h2 id="1-31"><a href="#1-31" class="headerlink" title="1.31"></a>1.31</h2><p>下列哪些是块级元素（）<br>A<br>input<br>B<br>ul<br>C<br>hr<br>D<br>li<br>E<br>div<br>F<br>form</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>（1）行内元素有：a b span img input select strong<br>  （2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p<br>  （3）常见的空元素：<br>  &lt; br&gt; &lt; hr&gt; &lt; img&gt; &lt; input&gt; &lt; link&gt; &lt; meta&gt;</p><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://juejin.cn/post/6844903922025365518?time=1675147924407">块级元素</a></div>              </div>            </details><hr><p>可继承的样式属性包括（）<br>A<br>color<br>B<br>background-color<br>C<br>font-size<br>D<br>border<br>E<br>margin</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>不可继承的：display、margin、border、padding、background、height、min-height、max- height、width、min-width、max-width、overflow、position、left、right、top、 bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、 page-bread-before和unicode-bidi。</p><p>所有元素可继承：visibility和cursor。</p><p>内联元素可继承：letter-spacing(字母间距)、word-spacing(字之间的空间)、white-space(元素内的空白怎样处理)、line-height(行高)、color、font、 font-family(元素的字体)、font-size、font-style(文本的字体样式)、font-variant(小型大写字母字体)、font-weight、text- decoration(文本装饰)、text-transform(控制文本的大小写)、direction。</p><p>块状元素可继承：text-indent(段落缩进)和text-align(文本水平对齐方式)。</p><p>列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。</p><p>表格元素可继承：border-collapse。</p>              </div>            </details><hr><p>http 请求方式 get 和 post 的区别包括（）<br>A<br>get和post的可传输内容大小不一样，一个有限制一个没有限制<br>B<br>get和post传输的内容存放的位置不一样，一个放在header，一个放在body<br>C<br>get请求Content-type只能是text/html<br>D<br>get请求可以跨域、post请求不能跨域</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>答案： A,B 至于C,D：<br> C . get请求Content-type只能是text&#x2F;html –错误，get的 Content-type不仅可以是 text&#x2F;html，也可以是其他，如 application&#x2F;json, text&#x2F;plain 等等<br> D. get请求可以跨域、post请求不能跨域 – 错误， post一样可以跨域</p>              </div>            </details><hr><p>下面哪些属于JavaScript的typeof运算符的可能结果：（）<br>A<br>symbol<br>B<br>int<br>C<br>boolean<br>D<br>null<br>E<br>array<br>F<br>undefined<br>G<br>string</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p><img src="https://uploadfiles.nowcoder.com/images/20190903/8018242_1567479495575_D3936A1FC6EBC59323A9A311B6076ABF" alt="code"></p>              </div>            </details><h2 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h2><p>以下表达式不会出现错误的有（）</p><p>2.toString()<br>2..toString()<br>2 .toString()<br>(2).toString()</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>数字后面.会被解析为小数点，而B、C、D则规避了这种情况。</p>              </div>            </details><hr><p>下列代码中，页面打开后能够弹出1的是？</p><iframe src=”javascript: alert(1)”></iframe><img src=”” onerror=”alert(1)”/>IE下<s style=”top:expression(alert(1))”></s><div onclick=”alert(1)”></div><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>我的答案是A B C<br>A 加载页面的时候触发；<br>B onerror   事件 当图片不存在时,将触发；<br>C 在ie 7下会连续弹出， IE5及其以后版本支持在CSS中使用expression，用来把CSS属性和Javascript表达式关联起来，这里的CSS属性可以是元素固有的属性，也可以是自定义属性。就是说CSS属性后面可以是一段Javascript表达式，CSS属性的值等于Javascript表达式计算的结果。 在表达式中可以直接引用元素自身的属性和方法，也可以使用其他浏览器对象。这个表达式就好像是在这个元素的一个成员函数中一样。参考资料 <a href="http://www.blueidea.com/tech/site/2006/3705.asp">http://www.blueidea.com/tech/site/2006/3705.asp</a><br>D 不可以,因为div里没有内容，盒子的宽度为0所以点击不了的；</p>              </div>            </details><hr><p>以下关于History对象的属性或方法描述正确的是（ ）</p><p>go表示刷新当前页面。<br>back回到浏览器载入历史URL地址列表的当前URL的前一个URL。<br>forward转到浏览器载入历史URL地址列表的当前URL的下一个URL。<br>length保存历史URL地址列表的长度信息。</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>正确答案: B C D<br>A go()方法从会话历史记录中加载特定页面。你可以使用它在历史记录中前后移动，具体取决于delta参数(1，-1都可)的值。<br>B back()方法会在会话历史记录中向后移动一页。如果没有上一页，则此方法调用不执行任何操作。<br>C 在会话历史中向前移动一页。它与使用delta参数为 1 时调用 history.go(delta)的效果相同。<br>D History.length 是一个只读属性，返回当前 session 中的 history 个数，包含当前页面在内。举个例子，对于新开一个 tab 加载的页面当前属性返回值 1。</p>              </div>            </details><hr><p>执行以下程序，输出结果为（）</p><p>class Phone{<br>  constructor(price){<br>    this.price = price;<br>  }<br>  get price(){<br>    return 999;<br>  }<br>}<br>var p = new Phone(888);<br>console.log(p.price);</p><p>999<br>undefined<br>抛出异常<br>888</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>本题报错：<br>这个类只设置了get方法，没有设置set方法，那么默认price属性是只读的，那就不能在constructor里再设置 this.price &#x3D; price<br><img src="https://uploadfiles.nowcoder.com/images/20220120/177279213_1642662187987/151EFEEAB8791BF48F04835BCF11793D" alt="code"></p><p>解决办法有两种：<br>        第一种：不要在constructor里设置 this.price &#x3D; price<br>        第二种：给这个类添加一个set 方法<br><img src="https://uploadfiles.nowcoder.com/images/20220120/177279213_1642662438354/362149FC665A49F916CAAB622086D816" alt="code"><br><img src="https://uploadfiles.nowcoder.com/images/20220120/177279213_1642662732851/922348DC3FFB0F0A661CA2DEACEDBDAA" alt="code"></p>              </div>            </details><hr><p>以下哪个语句打印出来的结果是false？<br>alert(3==true)<br>alert(2=="2")<br>alert(null == undefined)<br>alert(isNaN("true"))</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>A.两边会转换为number类型进行比较，true转换为number类型后，结果应该为 3 &#x3D;&#x3D; 1所以结果应该为false.<br>B.&#x3D;&#x3D;会进行隐式转换<br>C.null &#x3D;&#x3D; undefined 为true, 大家可以直接记住<br>D.全局函数isNaN()是判断是否不是number类型，因此结果为true</p>              </div>            </details><hr><h2 id="2-15"><a href="#2-15" class="headerlink" title="2.15"></a>2.15</h2><p>JS定义方法不正确的是（）<br>A<br>function a := function(){};<br>B<br>var a() = function{};<br>C<br>var string:a = (){};<br>D<br>都不正确</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>函数自定义的三种方式：</p><ol><li>函数声明式：需给函数命名，可声明提前<br> function 函数名 () {}</li><li>函数表达式&#x2F;匿名函数：无需给函数命名，不可声明提前（推荐）<br> var 变量名 &#x3D; function () {};</li><li>构造函数：<br> var 函数名 &#x3D; new Function();</li><li>立即执行函数：<br> (function () {}) ();    &#x2F;&#x2F;推荐<br> (function () {} ());<br> !function () {} ();</li><li>箭头函数：ES6新增<br> 没有参数时：<br> ( ) &#x3D;&gt; {  }<br> 只有一个参数时：<br> 参数 &#x3D;&gt; {  }<br> (单一参数) &#x3D;&gt; {  }<br> 多参数时：<br> (参数1，参数2，…，参数n) &#x3D;&gt; {  }<br> (参数1，参数2，…，参数n) &#x3D;&gt; 表达式<br> &#x2F;&#x2F;相当于 (参数1，参数2，…，参数n) &#x3D;&gt; {return 表达式}</li></ol>              </div>            </details><hr><p>关于ES6解构表达式<br>1<br>let [a,b, c,d, e] = "hello";<br>描述正确的是（）<br>A<br>e = "hello";其它都为undefined<br>B<br>当中 a = "h", b = "e";<br>C<br>语法报错</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>字符串的解构赋值<br>字符串也可以解构赋值，因为此时字符串被转换成一个类似数组的对象<br>let [a,b, c,d, e] &#x3D; “hello”;<br>console.log(a);    &#x2F;&#x2F;h<br>console.log(b);    &#x2F;&#x2F;e<br>console.log(c);    &#x2F;&#x2F;l<br>console.log(d);    &#x2F;&#x2F;l<br>console.log(e);    &#x2F;&#x2F;o<br>类似数组的对象都有一个 length 属性，因此还可以对这个属性解构赋值<br>let {length : len} &#x3D; ‘hello’;<br>console.log(len);    &#x2F;&#x2F;5</p>              </div>            </details><hr><p>关于ES6 箭头函数 ()=>{} ，描述错误的是（）<br>A<br>当箭头函数没有参数或有大于等于两个的参数时，必须使用括号，如：let a = ()=>{} 或 let a = (b, c) => {};<br>B<br>箭头函数没有arguments 绑定<br>C<br>箭头函数的this是函数定义的对象，而不是使用函数的对象<br>D<br>var f = v => v;以上语法有误</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>var f &#x3D; v &#x3D;&gt; v<br>var f &#x3D; function (v) { return v; }</p>              </div>            </details><hr><p>当HTML页面加载完毕时触发的事件是</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>window.onload &#x3D; function(){}</p>              </div>            </details><hr><p>JS中，使用什么属性可以对Dog类进行添加方法eat(   )<br>提示：<br>Dog.（）.eat = function(   ){}</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>prototype</p>              </div>            </details><hr><p>请使用Promise封装Ajax操作<br>原始的Ajax操作如下：</p><p>var onSuccess = function(result){}; //成功的回调<br>var onFail = function(error){}; //失败的回调<br>var req = new XMLHttpRequest();<br>req.open("POST", "<a href="http://www.baidu.com&quot;/">www.baidu.com&quot;</a>, true);<br>req.onload = function(){<br>  if(req.readyState === 4 && req.status === 200){<br>    onSuccess(req.response);<br>  } else {<br>    onFail(req.statusText);<br>  }<br>}<br>req.onerror = function(){<br>  onFail(Error("网络异常"));<br>}</p><details class="folding-tag" cyan><summary> 解析 </summary>              <div class='content'>              <p>return new Promise(function(resolve, reject){<br>   var req &#x3D; new XMLHttpRequest();<br>   req.open(“POST”, “<a href="http://www.baidu.com" target="_blank">www.baidu.com", true);<br>   req.onload &#x3D; function(){<br>     if(req.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; req.status &#x3D;&#x3D;&#x3D; 200){<br>       resolve(req.response);<br>     } else {<br>       reject(req.statusText);<br>     }<br>   }<br>   req.onerror &#x3D; function(){<br>     reject(Error(“网络异常”));<br>   }<br> });</a></p>              </div>            </details><hr>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 双指针</title>
      <link href="/2022/12/19/%E5%89%91%E6%8C%87%20Offer%20%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2022/12/19/%E5%89%91%E6%8C%87%20Offer%20%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h1><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题可以用很简单的方法实现，比如：</p><blockquote><blockquote><p>const replaceSpace &#x3D; s &#x3D;&gt; s.split(‘ ‘).join(‘%20’);</p></blockquote></blockquote><p>或者直接用 replace 也可以。</p><p>但要我们自己手动实现的话，可以使用双指针解法：</p><p>1.先统计空格数量    </p><p>2.字符串转化为数组，更新数组长度</p><p>3.定义双指针：left:旧长度-1、right:新长度-1</p><p>4.从后往前遍历，如果左指针遇到空格，右指针依次填入%20，并左移 2</p><p>5.如果左指针遇到字符，直接将左指针的值赋给右指针</p><p>6.左指针和右指针还有分别左移 1</p><p>7.最后返回字符串</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><blockquote><blockquote><p>输入：s &#x3D; “We are happy.”<br>输出：”We%20are%20happy.”</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var replaceSpace = function(s) &#123;<br><br>    s = s.split(&#x27;&#x27;)<br><br>        let oldLength = s.length<br>        let spaceCount = 0<br><br>        // 先计算有多少个空格<br>        for(let i=0;i<oldLength;i++)&#123;<br>            if(s[i] === &#x27; &#x27;) spaceCount++<br>        &#125;<br><br>    // 使用新字符串代替旧字符串<br>    s.length += spaceCount*2<br>    for(let i=oldLength-1,j=s.length-1;i>=0;i--,j--)&#123;<br>        if(s[i] !== &#x27; &#x27;) s[j] = s[i]<br>        else&#123;<br>            s[j-2] = &#x27;%&#x27;;<br>            s[j-1] = &#x27;2&#x27;;<br>            s[j] = &#x27;0&#x27;;<br>            j-=2<br><br>         &#125;<br>    &#125;return s.join(&#x27;&#x27;);<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</h1><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>1.定义双指针</p><p>2.左指针找偶数，右指针找奇数</p><p>3.交换左右指针的值</p><p>4.循环寻找</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><blockquote><blockquote><p>输入：nums &#x3D; [1,2,3,4]<br>输出：[1,3,2,4]<br>注：[3,1,2,4] 也是正确的答案之一。</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var exchange = function(nums) &#123;<br><br>    let l = 0,r = nums.length - 1<br><br>    while(l<r)&#123;<br>        if(nums[l]%2==0 && nums[r]%2==1)&#123;<br>            let tmp = nums[l]<br>            nums[l] = nums[r]<br>            nums[r] = tmp<br>        &#125;<br><br>        if(nums[l] % 2 === 1) l++<br>        // ?: 右边的应该向左边靠齐<br>        if(nums[r] % 2 === 0) r--<br>    &#125;return nums<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="剑指-Offer-22-链表中倒数第-k-个节点"><a href="#剑指-Offer-22-链表中倒数第-k-个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第 k 个节点"></a>剑指 Offer 22. 链表中倒数第 k 个节点</h1><p>输入一个链表，输出该链表中倒数第 k 个节点。为了符合大多数人的习惯，本题从 1 开始计数，即链表的尾节点是倒数第 1 个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>1.定义快慢指针，初始都指向链表头部</p><p>2.快指针先走 k 步</p><p>3.再两指针一起走，直到快指针走到头为止</p><p>4.此时的慢指针指向的就是倒数第 k 个节点</p><p>5.返回慢指针即可</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><blockquote><blockquote><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</p></blockquote></blockquote><blockquote><blockquote><p>返回链表 4-&gt;5.</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var getKthFromEnd = function(head, k) &#123;<br><br>    // 使用双指针方法<br>    let fast = head,slow = head<br><br>    // 先迭代k次，此处注意k反过来 --<br>    while(fast && k>0)&#123;<br>        fast = fast.next<br>        k--<br>    &#125;<br><br>    // 不多解释<br>    while(fast)&#123;<br>        fast = fast.next<br>        slow = slow.next<br>    &#125;<br>    // 注意返回直接slow 就行<br>    return slow<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a>剑指 Offer 25. 合并两个排序的链表</h1><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>1.思路都在注释中，稍微画一下图就懂了</p><p>2.定义一个虚拟节点，最后返回虚拟节点的下一个节点</p><p>3.定义 p1，p2 分别指向两个链表头部，一起遍历</p><p>4.p1 和 p2 哪个对应的值小，哪个就连接到答案链表</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><blockquote><blockquote><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var mergeTwoLists = function(l1, l2) &#123;<br><br>    // 搞一个哨兵节点<br>    const prev = new ListNode(-1)<br><br>    let pre = prev<br>    while(l1 != null && l2 != null)&#123;<br>        // 谁小就把小的节点放在pre的后面<br>        if(l1.val<=l2.val)&#123;<br>            pre.next = l1<br>            l1 = l1.next<br>        &#125;else&#123;<br>            pre.next = l2<br>            l2 = l2.next<br>        &#125;<br>        pre = pre.next<br>    &#125;<br><br>    pre.next = l1 === null ? l2 : l1<br>    // 此处是返回prev<br>    return prev.next<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="剑指-Offer-57-和为-s-的两个数字"><a href="#剑指-Offer-57-和为-s-的两个数字" class="headerlink" title="剑指 Offer 57. 和为 s 的两个数字"></a>剑指 Offer 57. 和为 s 的两个数字</h1><p>输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是 s。如果有多对数字的和等于 s，则输出任意一对即可。</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p><strong>给的数字数组是升序排列的，故用双指针法求解：</strong></p><p>1.定义双指针分别指向数组头尾，即最小、最大的数</p><p>2.判断左右指针对应的数之和，与目标数的关系</p><p>3.若大于目标数，需要小一点，右指针左移</p><p>4.若小于目标数，需要大一点，左指针右移</p><p>5.若等于目标数，返回这两个数</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><blockquote><blockquote><p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[2,7] 或者 [7,2]</p></blockquote></blockquote><blockquote><blockquote><p>输入：nums &#x3D; [10,26,30,31,47,60], target &#x3D; 40<br>输出：[10,30] 或者 [30,10]</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var twoSum = function(nums, target) &#123;<br><br>    let [l,r] = [0,nums.length-1]<br><br>    //?: 因为是递增排序数组,不是乱序<br>    while(l<r)&#123;<br>        // 直接列出和,来缩小l和r的范围<br>        let sum = nums[l] + nums[r]<br>        if(sum > target)&#123;<br>            r--<br>        &#125;else if(sum < target)&#123;<br>            l++<br>        &#125;else&#123;<br>            return [nums[l],nums[r]]<br>        &#125;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="剑指-Offer-57-II-和为-s-的连续正数序列"><a href="#剑指-Offer-57-II-和为-s-的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为 s 的连续正数序列"></a>剑指 Offer 57 - II. 和为 s 的连续正数序列</h1><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>1.滑动窗口思路，窗口初始化为[1, 2]，初始 sum 为 3</p><p>2.因为输出的序列至少有 2 个数，所以若窗口第一个数大于 target&#x2F;2 时，就不再继续了</p><p>3.若 sum 太小，向窗口添加下一个数，更新 sum</p><p>4.若 sum 太大，弹出窗口第一个数，更新 sum</p><p>5.若 sum&#x3D;&#x3D;&#x3D;target，则将窗口的数放入 res，随后弹出第一个数，继续滑动</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><blockquote><blockquote><p>输入：target &#x3D; 9<br>输出：[[2,3,4],[4,5]]</p></blockquote></blockquote><blockquote><blockquote><p>输入：target &#x3D; 15<br>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var findContinuousSequence = function(target) &#123;<br>// 先把数分解 9=1+8=2+7=3+6=4+5,按这种，找到可能组成正确结果的数组，根据数的结构，易知结果可能存在[1,2,3,4,5]中，不难发现数组最后一个数,如果 target 是偶数就是 target/2,如果是奇数就是 target/2 取整加一，即 Math.floor(target/2)+1 或采用二进制取整(target/2 | 0) + 1。<br>let index = target % 2 === 0 ? target / 2 : (target / 2 | 0) + 1<br><br>    let res = []<br><br>    let temp = []<br><br>    let sum = 0<br><br>    for (let i = 1; i <= index; i++) &#123;<br>        temp.push(i)<br>        sum = sum + i<br><br>        while (sum > target) &#123;<br>            sum -= temp[0]<br>            temp.shift()<br>    &#125;<br><br>    if (sum === target) &#123;<br>      temp.length >= 2 && res.push([...temp])<br>    &#125;<br><br>&#125;<br>return res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 Offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 链表</title>
      <link href="/2022/12/19/%E5%89%91%E6%8C%87%20Offer%20%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/12/19/%E5%89%91%E6%8C%87%20Offer%20%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a>剑指 Offer 06. 从尾到头打印链表</h1><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用一个辅助栈，遍历链表时，先将元素放入辅助栈。</p><p>最后从尾遍历辅助栈。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><blockquote><blockquote><p>输入：head &#x3D; [1,3,2]<br>输出：[2,3,1]</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var reversePrint = function(head,arr = []) &#123;<br><br>    if(head != null)&#123;<br><br>        // 通过递归，反着的属性，先把最后面的数字输入到最前面<br>        if(head.next != null)&#123;<br>            reversePrint(head.next,arr)<br>        &#125;<br>        arr.push(head.val)<br>    &#125;<br>    return arr<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a>剑指 Offer 18. 删除链表的节点</h1><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p>注意：此题对比原题有改动</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>1.定义虚拟节点，用指针遍历链表</p><p>2.如果下一个值等于 val，则删除下一个值</p><p>3.使用 ES6 的?.运算符，判断 p 是否存在</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><blockquote><blockquote><p>输入: head &#x3D; [4,5,1,9], val &#x3D; 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p></blockquote></blockquote><blockquote><blockquote><p>输入: head &#x3D; [4,5,1,9], val &#x3D; 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var deleteNode = function(head, val) &#123;<br><br>    // 递归终止条件： head为空<br>    if(head === null)  return head<br><br>    // 删除节点 => 返回下一节点<br>    if(head.val === val)  return head.next<br><br>    // 使用递归<br>    head.next = deleteNode(head.next,val)<br>    return head<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a>剑指 Offer 24. 反转链表</h1><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>指针遍历链表，边遍历边改变指向。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><blockquote><blockquote><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var reverseList = function(head) &#123;<br><br>    // 看到反转，首先想到递归<br>    if(!head || !head.next)  return head<br><br>    // let 能加速？<br>    let res = reverseList(head.next)<br><br>    // *反转规则:  将head.next 的 next指针 指向 head<br>    head.next.next = head<br>    // 断开 原有指向<br>    head.next = null<br><br>    return res<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a>剑指 Offer 25. 合并两个排序的链表</h1><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>1.思路都在注释中，稍微画一下图就懂了</p><p>2.定义一个虚拟节点，最后返回虚拟节点的下一个节点</p><p>3.定义 p1，p2 分别指向两个链表头部，一起遍历</p><p>4.p1 和 p2 哪个对应的值小，哪个就连接到答案链表</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><blockquote><blockquote><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var mergeTwoLists = function(l1, l2) &#123;<br><br>    // 搞一个哨兵节点<br>    const prev = new ListNode(-1)<br><br>    let pre = prev<br>    while(l1 != null && l2 != null)&#123;<br>        // 谁小就把小的节点放在pre的后面<br>        if(l1.val<=l2.val)&#123;<br>            pre.next = l1<br>            l1 = l1.next<br>        &#125;else&#123;<br>            pre.next = l2<br>            l2 = l2.next<br>        &#125;<br>        pre = pre.next<br>    &#125;<br><br>    pre.next = l1 === null ? l2 : l1<br>    // 此处是返回prev<br>    return prev.next<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="剑指-Offer-57-和为-s-的两个数字"><a href="#剑指-Offer-57-和为-s-的两个数字" class="headerlink" title="剑指 Offer 57. 和为 s 的两个数字"></a>剑指 Offer 57. 和为 s 的两个数字</h1><p>输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是 s。如果有多对数字的和等于 s，则输出任意一对即可。</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p><strong>给的数字数组是升序排列的，故用双指针法求解：</strong></p><p>1.定义双指针分别指向数组头尾，即最小、最大的数</p><p>2.判断左右指针对应的数之和，与目标数的关系</p><p>3.若大于目标数，需要小一点，右指针左移</p><p>4.若小于目标数，需要大一点，左指针右移</p><p>5.若等于目标数，返回这两个数</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><blockquote><blockquote><p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[2,7] 或者 [7,2]</p></blockquote></blockquote><blockquote><blockquote><p>输入：nums &#x3D; [10,26,30,31,47,60], target &#x3D; 40<br>输出：[10,30] 或者 [30,10]</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var twoSum = function(nums, target) &#123;<br><br>    let [l,r] = [0,nums.length-1]<br><br>    //?: 因为是递增排序数组,不是乱序<br>    while(l<r)&#123;<br>        // 直接列出和,来缩小l和r的范围<br>        let sum = nums[l] + nums[r]<br>        if(sum > target)&#123;<br>            r--<br>        &#125;else if(sum < target)&#123;<br>            l++<br>        &#125;else&#123;<br>            return [nums[l],nums[r]]<br>        &#125;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="剑指-Offer-57-II-和为-s-的连续正数序列"><a href="#剑指-Offer-57-II-和为-s-的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为 s 的连续正数序列"></a>剑指 Offer 57 - II. 和为 s 的连续正数序列</h1><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>1.滑动窗口思路，窗口初始化为[1, 2]，初始 sum 为 3</p><p>2.因为输出的序列至少有 2 个数，所以若窗口第一个数大于 target&#x2F;2 时，就不再继续了</p><p>3.若 sum 太小，向窗口添加下一个数，更新 sum</p><p>4.若 sum 太大，弹出窗口第一个数，更新 sum</p><p>5.若 sum&#x3D;&#x3D;&#x3D;target，则将窗口的数放入 res，随后弹出第一个数，继续滑动</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><blockquote><blockquote><p>输入：target &#x3D; 9<br>输出：[[2,3,4],[4,5]]</p></blockquote></blockquote><blockquote><blockquote><p>输入：target &#x3D; 15<br>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var findContinuousSequence = function(target) &#123;<br>// 先把数分解 9=1+8=2+7=3+6=4+5,按这种，找到可能组成正确结果的数组，根据数的结构，易知结果可能存在[1,2,3,4,5]中，不难发现数组最后一个数,如果 target 是偶数就是 target/2,如果是奇数就是 target/2 取整加一，即 Math.floor(target/2)+1 或采用二进制取整(target/2 | 0) + 1。<br>let index = target % 2 === 0 ? target / 2 : (target / 2 | 0) + 1<br><br>    let res = []<br><br>    let temp = []<br><br>    let sum = 0<br><br>    for (let i = 1; i <= index; i++) &#123;<br>        temp.push(i)<br>        sum = sum + i<br><br>        while (sum > target) &#123;<br>            sum -= temp[0]<br>            temp.shift()<br>    &#125;<br><br>    if (sum === target) &#123;<br>      temp.length >= 2 && res.push([...temp])<br>    &#125;<br><br>&#125;<br>return res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 Offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 二分查找</title>
      <link href="/2022/12/18/%E5%89%91%E6%8C%87%20Offer%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/12/18/%E5%89%91%E6%8C%87%20Offer%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a>剑指 Offer 04. 二维数组中的查找</h1><p>在一个 n * m 的二维数组中，每一行都按照从左到右<strong>非递减</strong>的顺序排序，每一列都按照从上到下<strong>非递减</strong>的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>类似二分查找的做法：</strong></p><p>1.从左下角开始寻找，因为左下角的元素是当前行最小的、当前列最大的</p><p>2.比较元素，如果太大了，上移一行</p><p>3.如果太小了，右移一列</p><p>4.找到就返回 true</p><p>5.遍历完，返回 false</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><blockquote><p>现有矩阵 matrix 如下：</p></blockquote><blockquote><blockquote><p>[<br>[1, 4, 7, 11, 15],<br>[2, 5, 8, 12, 19],<br>[3, 6, 9, 16, 22],<br>[10, 13, 14, 17, 24],<br>[18, 21, 23, 26, 30]<br>]</p></blockquote></blockquote><blockquote><p>给定 target &#x3D; 5，返回 true。</p></blockquote><blockquote><p>给定 target &#x3D; 20，返回 false。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var findNumberIn2DArray = function(matrix, target) &#123;<br>// 基础工作<br>if(!matrix.length) return false<br><br>    let x = matrix.length - 1,y = 0<br>    while(x>=0 && y <= matrix[0].length)&#123;<br>        // 如果相等<br>        if(matrix[x][y] === target)&#123;<br>            return true<br>        // 如果比它大，往上移一位<br>        &#125;else if(matrix[x][y] > target)&#123;<br>            x--<br>        // 如果比他小，往右移一为<br>        &#125;else&#123;<br>            y++<br>        &#125;<br>    &#125;return false<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a>剑指 Offer 11. 旋转数组的最小数字</h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>给你一个可能存在<strong>重复</strong>元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的<strong>最小元素</strong>。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。</p><p>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><blockquote><p>输入：numbers &#x3D; [3,4,5,1,2]<br>输出：1</p></blockquote><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><blockquote><p>输入：numbers &#x3D; [2,2,2,0,1]<br>输出：0</p></blockquote><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>1.用二分查找即可</p><p>2.若 mid 大于 high 的数，则最小值一定在 mid 右侧</p><p>3.若 mid 小于 high 的数，则最小值有两种可能：(1)最小值在 mid 最侧(2)mid 就是最小值</p><p>4.若 mid 等于 high 的数，high–</p><p>5.最后返回 low 所在的数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var minArray = function(numbers) &#123;<br>let low = 0<br>let hign = numbers.length-1<br>while(low<hign)&#123;<br>const pivot = low + Math.floor((hign-low)/2)<br><br>        if(numbers[pivot]<numbers[hign])&#123;<br>            hign = pivot<br>        &#125;else if(numbers[pivot]>numbers[hign])&#123;<br>            // 针对示例1<br>            low = pivot + 1;<br>        &#125;else &#123;<br>           high -= 1;<br>        &#125;<br>    &#125;<br>    return numbers[low];<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a>剑指 Offer 53 - I. 在排序数组中查找数字 I</h1><p>统计一个数字在排序数组中出现的次数。</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><blockquote><p>输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>输出: 2</p></blockquote><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><blockquote><p>输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>输出: 0</p></blockquote><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>已经排序好的数组，推荐使用二分搜索。</p><p>先用二分搜索找到目标数的一个索引，再从两边扩散，统计数量。</p><p>若二分查找没找到目标数，直接返回 0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">const search = (nums, target)=>&#123;<br>let [low,hign,flag] = [0,nums.length-1,null]<br><br>    while(low<=hign)&#123;<br>        const mid = (low+hign) >> 1<br>        const midNums = nums[mid]<br>        if(midNums>target)&#123;<br>            // midNums大于target,low向中间缩小范围<br>            hign = mid -1<br>        &#125;else if(midNums<target)&#123;<br>            // midNum小于target,hign向中缩小范围<br>            low = mid + 1<br>        &#125;else&#123;<br>            flag = mid<br>            break<br>        &#125;<br>    &#125;<br>    if(flag === null) return 0<br><br>    low = hign = flag<br>    while(nums[low-1] === target) low--<br>    while(nums[hign+1] === target) hign++<br>    return hign-low+1<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="剑指-Offer-53-I-在排序数组中查找数字-I-1"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I-1" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a>剑指 Offer 53 - I. 在排序数组中查找数字 I</h1><p>一个长度为 n-1 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围 0 ～ n-1 之内。在范围 0 ～ n-1 内的 n 个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><blockquote><p>输入: 输入: [0,1,3]<br>输出: 2</p></blockquote><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><blockquote><p>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8</p></blockquote><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>有序数组 ——&gt; 二分查找</p><p>nums[mid] &#x3D;&#x3D;&#x3D; mid：左半边完整，缩小范围，开始找右半边</p><p>nums[mid] !&#x3D;&#x3D; mid：左半边不完整，缩小范围，在左半边找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">var missingNumber = function(nums) &#123;<br>// 递增排序数组,第一想的就应该是 二分法<br>let [low,hign] = [0,nums.length-1]<br><br>    while(low<=hign)&#123;<br>        let mid = (low + hign) >> 1<br>        if(nums[mid] == mid)&#123;<br>            low = mid + 1<br>        &#125;else&#123;<br>            hign = mid - 1<br>        &#125;<br>    &#125;return low<br><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 Offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>更新日志</title>
      <link href="/2022/11/17/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"/>
      <url>/2022/11/17/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="12-15"><a href="#12-15" class="headerlink" title="12.15"></a>12.15</h2><p>添加 Aplayer 音乐播放器,并添加了全局吸底</p><p>代码高亮优化，加好看的边框</p><h2 id="12-19"><a href="#12-19" class="headerlink" title="12.19"></a>12.19</h2><p>剑指 Offer 双指针</p><h2 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h2><p>Vue 笔记</p><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://v2.cn.vuejs.org/v2/api/#%E6%8C%87%E4%BB%A4">指令</a></div><h2 id="1-12"><a href="#1-12" class="headerlink" title="1.12"></a>1.12</h2><p>组件 的 复习</p><h2 id="1-15"><a href="#1-15" class="headerlink" title="1.15"></a>1.15</h2><p>组件 的 复习</p><h2 id="1-17"><a href="#1-17" class="headerlink" title="1.17"></a>1.17</h2><p>过渡 &amp; 动画 的样式</p><h2 id="1-18"><a href="#1-18" class="headerlink" title="1.18"></a>1.18</h2><p>mixin，NextTick 的 初次理解</p><h2 id="1-19"><a href="#1-19" class="headerlink" title="1.19"></a>1.19</h2><p>slot的理解,Vue.observable,key的原理</p><h2 id="1-20"><a href="#1-20" class="headerlink" title="1.20"></a>1.20</h2><p>keep-alive的理解,Vue常用的修饰符</p><h2 id="1-21"><a href="#1-21" class="headerlink" title="1.21"></a>1.21</h2><p>自定义指令,过滤器,虚拟DOM,diff算法,封装axios</p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/-data/link.json"/>
      <url>/-data/link.json</url>
      
        <content type="html"><![CDATA[[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"糖果屋のVIP","class_desc":"售后服务享五折优惠2333","link_list":[{"name":"Akilar","link":"https://akilar.top","avatar":"/img/siteicon/favicon.png","descr":"欢迎光临糖果屋","siteshot":"https://cdn.jsdelivr.net/gh/Akilarlxh/ScreenShot@gh-pages/akilar.top.jpg"}]}]]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<!-- GitCalendar容器 --><div id="gitZone"></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>便携小空调 - 为你的夏日带去清凉!</title>
      <link href="/air-conditioner/index.html"/>
      <url>/air-conditioner/index.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>终于为博客安装上了便携小空调</p></blockquote><style>.copyright-box a {  border-bottom: none !important;  padding: 0 !important;}</style><div id="air-conditioner-vue"></div><script defer data-pjax src='https://alist.anzhiy.cn/d/anzhiyu/air-conditioner-dev/index.2d8c3a3f.js'></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/Kimbiedark.css"/>
      <url>/css/Kimbiedark.css</url>
      
        <content type="html"><![CDATA[/*    Name:     Kimbie (dark)    Author:   Jan T. Sott    License:  Creative Commons Attribution-ShareAlike 4.0 Unported License    URL:      https://github.com/idleberg/Kimbie-highlight.js*//* 新添加的内容  -------------------------------------   --hl-color                  代码框字体顔色 【必须】 (把下面.hljs的 color复制到这里来)  --hl-bg                     代码框背景色 【必须】 (把下面.hljs的 background复制到这里来)  --hltools-bg: #321a0f       代码框顶部工具栏背景色 【可选】(如果你关掉了 copy、lang 和 shrink,可不用配置这个）  --hltools-color: #fff       代码框顶部工具栏字体顔色 【可选】(如果你关掉了 copy、lang 和 shrink,可不用配置这个）  --hlnumber-bg: #221a0f      代码框行数背景色 【可选】(如果已经关掉 line_number,可以不用配置这个)  --hlnumber-color: #fff      代码框行数字体顔色 【可选】 (如果已经关掉 line_number,可以不用配置这个)  --hlscrollbar-bg: #d3af86   代码框滚动条顔色 【可选】（默认为主题主顔色）  --hlexpand-bg: #d3af86      代码框底部展开背景色 【可选】(如果已经关掉 highlight_height_limit,可以不用配置这个)*/:root {    --hl-color: #d3af86;    --hl-bg: #221a0f;    --hltools-bg: #321a0f;    --hltools-color: #fff;    --hlnumber-bg: #221a0f;    --hlnumber-color: #fff;    --hlscrollbar-bg: #d3af86;    --hlexpand-bg: #d3af86;  }    /* Kimbie Comment */  .hljs-comment,  .hljs-quote {    color: #d6baad;  }    /* Kimbie Red */  .hljs-variable,  .hljs-template-variable,  .hljs-tag,  .hljs-name,  .hljs-selector-id,  .hljs-selector-class,  .hljs-regexp,  .hljs-meta {    color: #dc3958;  }    /* Kimbie Orange */  .hljs-number,  .hljs-built_in,  .hljs-builtin-name,  .hljs-literal,  .hljs-type,  .hljs-params,  .hljs-deletion,  .hljs-link {    color: #f79a32;  }    /* Kimbie Yellow */  .hljs-title,  .hljs-section,  .hljs-attribute {    color: #f06431;  }    /* Kimbie Green */  .hljs-string,  .hljs-symbol,  .hljs-bullet,  .hljs-addition {    color: #889b4a;  }    /* Kimbie Purple */  .hljs-keyword,  .hljs-selector-tag,  .hljs-function {    color: #98676a;  }    /* 更改的内容 把.hljs改为 #article-container figure.highlight .hljs *、  /* ------------------------------------- */  #article-container figure.highlight .hljs {    display: block;    overflow-x: auto;    background: #221a0f;    color: #d3af86;    padding: 0.5em;  }    .hljs-emphasis {    font-style: italic;  }    .hljs-strong {    font-weight: bold;  }  ]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 一级菜单居中 */#nav .menus_items {    position: absolute !important;    width: fit-content !important;    left: 50% !important;    transform: translateX(-50%) !important;  }  /* 子菜单横向展示 */  #nav .menus_items .menus_item:hover .menus_item_child {    display: flex !important;  }  /* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */  .menus_items .menus_item:nth-child(2) .menus_item_child {    left: -125px;  }  /* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}/* 夜间模式菜单栏发光字 */[data-theme="dark"] #nav .site-page,[data-theme="dark"] #nav .menus_items .menus_item .menus_item_child li a {  text-shadow: 0 0 2px rgb(179, 71, 241) !important;}/* 手机端适配 */[data-theme="dark"] #sidebar #sidebar-menus .menus_items .site-page {  text-shadow: 0 0 2px rgb(179, 71, 241) !important;}/* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {  background: linear-gradient(    -45deg,    #e8d8b9,    #eccec5,    #a3e9eb,    #bdbdf0,    #eec1ea  );  box-shadow: 0 0 5px rgb(66, 68, 68);  position: relative;  background-size: 400% 400%;  -webkit-animation: Gradient 10s ease infinite;  -moz-animation: Gradient 10s ease infinite;  animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@-moz-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content > .card-widget.card-info {  background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content > .card-widget.card-info > #card-info-btn {  background-color: #3eb8be;  border-radius: 8px;}/* 颜色 */:root {  --anzhiyu-theme-op: #4259ef23;  --anzhiyu-card-bg-none: rgba(255, 255, 255, 0);  --anzhiyu-main-op-deep: var(--anzhiyu-theme-op-deep) !important;  --anzhiyu-gray-op: #9999992b;  --anzhiyu-theme-top: var(--anzhiyu-theme);  --anzhiyu-white: #fff;  --anzhiyu-white-op: rgba(255, 255, 255, 0.2);  --anzhiyu-black: #000;  --anzhiyu-black-op: rgba(0, 0, 0, 0.2);  --anzhiyu-none: rgba(0, 0, 0, 0);  --anzhiyu-gray: #999999;  --anzhiyu-yellow: #ffc93e;  --anzhiyu-orange: #e38100;  --anzhiyu-border-radius: 8px;  --anzhiyu-main: var(--anzhiyu-theme);  --anzhiyu-main-op: var(--anzhiyu-theme-op);  --anzhiyu-shadow-theme: 0 8px 12px -3px var(--anzhiyu-theme-op);  --anzhiyu-shadow-main: 0 8px 12px -3px var(--anzhiyu-main-op);  --anzhiyu-shadow-blue: 0 8px 12px -3px rgba(40, 109, 234, 0.2);  --anzhiyu-shadow-white: 0 8px 12px -3px rgba(255, 255, 255, 0.2);  --anzhiyu-shadow-black: 0 0 12px 4px rgba(0, 0, 0, 0.05);  --anzhiyu-shadow-yellow: 0px 38px 77px -26px rgba(255, 201, 62, 0.12);  --anzhiyu-shadow-red: 0 8px 12px -3px #ee7d7936;  --anzhiyu-shadow-green: 0 8px 12px -3px #87ee7936;  --anzhiyu-shadow-border: 0 8px 16px -4px #2c2d300c;  --anzhiyu-shadow-blackdeep: 0 2px 16px -3px rgba(0, 0, 0, 0.15);  --anzhiyu-logo-color: linear-gradient(215deg, #4584ff 30%, #ff7676 70%);  --style-border: 1px solid var(--anzhiyu-card-border);  --anzhiyu-blue-main: #3b70fc;  --style-border-hover: 1px solid var(--anzhiyu-main);  --style-border-dashed: 1px dashed var(--anzhiyu-theme-op);  --style-border-avatar: 4px solid var(--anzhiyu-background);  --style-border-always: 1px solid var(--anzhiyu-card-border);  --style-border-none: 1px solid transparent;  --anzhiyu-white-acrylic1: #fefeff !important;  --anzhiyu-white-acrylic2: #fcfdff !important;  --anzhiyu-black-acrylic2: #08080a !important;  --anzhiyu-black-acrylic1: #0b0b0e !important;  --anzhiyu-main-none: #b8b8b800 !important;}[data-theme="light"] {  --anzhiyu-theme-op-deep: #4259efdd;  --global-bg: #f7f9fe;  --anzhiyu-theme: #3b70fc;  --anzhiyu-theme-deep: #1856fb;  --anzhiyu-theme-op: #4259ef23;  --anzhiyu-blue: #3b70fc;  --anzhiyu-red: #d8213c;  --anzhiyu-pink: #ff7c7c;  --anzhiyu-green: #57bd6a;  --anzhiyu-fontcolor: #363636;  --anzhiyu-background: #f7f9fe;  --anzhiyu-reverse: #000;  --anzhiyu-maskbg: rgba(255, 255, 255, 0.6);  --anzhiyu-maskbgdeep: rgba(255, 255, 255, 0.85);  --anzhiyu-hovertext: var(--anzhiyu-theme);  --anzhiyu-ahoverbg: #f7f7fa;  --anzhiyu-lighttext: var(--anzhiyu-main);  --anzhiyu-secondtext: rgba(60, 60, 67, 0.6);  --anzhiyu-scrollbar: rgba(60, 60, 67, 0.4);  --anzhiyu-card-btn-bg: #edf0f7;  --anzhiyu-post-blockquote-bg: #fafcff;  --anzhiyu-post-tabs-bg: #f2f5f8;  --anzhiyu-secondbg: #f1f3f8;  --anzhiyu-shadow-nav: 0 5px 12px -5px rgba(102, 68, 68, 0.05);  --anzhiyu-card-bg: #fff;  --anzhiyu-shadow-lightblack: 0 5px 12px -5px rgba(102, 68, 68, 0);  --anzhiyu-shadow-light2black: 0 5px 12px -5px rgba(102, 68, 68, 0);  --anzhiyu-card-border: #e3e8f7;}[data-theme="dark"] {  --anzhiyu-theme-op-deep: #0084ffdd;  --global-bg: #18171d;  --anzhiyu-theme: #0084ff;  --anzhiyu-theme-deep: #0076e5;  --anzhiyu-theme-op: #0084ff23;  --anzhiyu-blue: #0084ff;  --anzhiyu-red: #ff3842;  --anzhiyu-pink: #ff7c7c;  --anzhiyu-green: #57bd6a;  --anzhiyu-fontcolor: #f7f7fa;  --anzhiyu-background: #18171d;  --anzhiyu-reverse: #fff;  --anzhiyu-maskbg: rgba(0, 0, 0, 0.6);  --anzhiyu-maskbgdeep: rgba(0, 0, 0, 0.85);  --anzhiyu-hovertext: #0a84ff;  --anzhiyu-ahoverbg: #fff;  --anzhiyu-lighttext: #f2b94b;  --anzhiyu-secondtext: #a1a2b8;  --anzhiyu-scrollbar: rgba(200, 200, 223, 0.4);  --anzhiyu-card-btn-bg: #30343f;  --anzhiyu-post-blockquote-bg: #000;  --anzhiyu-post-tabs-bg: #121212;  --anzhiyu-secondbg: #30343f;  --anzhiyu-shadow-nav: 0 5px 20px 0px rgba(28, 28, 28, 0.4);  --anzhiyu-card-bg: #1d1b26;  --anzhiyu-shadow-lightblack: 0 5px 12px -5px rgba(102, 68, 68, 0);  --anzhiyu-shadow-light2black: 0 5px 12px -5px rgba(102, 68, 68, 0);  --anzhiyu-card-border: #42444a;}/* 文章页H1-H6图标样式效果 *//* 控制风车转动速度 4s那里可以自己调节快慢 */h1::before,h2::before,h3::before,h4::before,h5::before,h6::before {  -webkit-animation: ccc 4s linear infinite;  animation: ccc 4s linear infinite;}/* 控制风车转动方向 -1turn 为逆时针转动，1turn 为顺时针转动，相同数字部分记得统一修改 */@-webkit-keyframes ccc {  0% {    -webkit-transform: rotate(0deg);    transform: rotate(0deg);  }  to {    -webkit-transform: rotate(-1turn);    transform: rotate(-1turn);  }}@keyframes ccc {  0% {    -webkit-transform: rotate(0deg);    transform: rotate(0deg);  }  to {    -webkit-transform: rotate(-1turn);    transform: rotate(-1turn);  }}/* 设置风车颜色 */#content-inner.layout h1::before {  color: #ef50a8;  margin-left: -1.55rem;  font-size: 1.3rem;  margin-top: -0.23rem;}#content-inner.layout h2::before {  color: #fb7061;  margin-left: -1.35rem;  font-size: 1.1rem;  margin-top: -0.12rem;}#content-inner.layout h3::before {  color: #ffbf00;  margin-left: -1.22rem;  font-size: 0.95rem;  margin-top: -0.09rem;}#content-inner.layout h4::before {  color: #a9e000;  margin-left: -1.05rem;  font-size: 0.8rem;  margin-top: -0.09rem;}#content-inner.layout h5::before {  color: #57c850;  margin-left: -0.9rem;  font-size: 0.7rem;  margin-top: 0rem;}#content-inner.layout h6::before {  color: #5ec1e0;  margin-left: -0.9rem;  font-size: 0.66rem;  margin-top: 0rem;}/* s设置风车hover动效 6s那里可以自己调节快慢*/#content-inner.layout h1:hover,#content-inner.layout h2:hover,#content-inner.layout h3:hover,#content-inner.layout h4:hover,#content-inner.layout h5:hover,#content-inner.layout h6:hover {  color: var(--theme-color);}#content-inner.layout h1:hover::before,#content-inner.layout h2:hover::before,#content-inner.layout h3:hover::before,#content-inner.layout h4:hover::before,#content-inner.layout h5:hover::before,#content-inner.layout h6:hover::before {  color: var(--theme-color);  -webkit-animation: ccc 6s linear infinite;  animation: ccc 6s linear infinite;}svg.icon {  width: 1em; height: 1em;  /* width和height定义图标的默认宽度和高度*/  vertical-align: -0.15em;  fill: currentColor;  overflow: hidden;}:root {  --trans-light: rgba(255, 255, 255, 0.88);  --trans-dark: rgba(25, 25, 25, 0.88);  --border-style: 1px solid rgb(169, 169, 169);  --backdrop-filter: blur(5px) saturate(150%);}/* 首页文章卡片 */#recent-posts > .recent-post-item {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 25px;  border: var(--border-style);}/* 首页侧栏卡片 */#aside-content .card-widget {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 18px;  border: var(--border-style);}/* 文章页、归档页、普通页面 */div#post,div#page,div#archive {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border: var(--border-style);  border-radius: 20px;}/* 导航栏 */#page-header.nav-fixed #nav {  background: rgba(255, 255, 255, 0.75);  backdrop-filter: var(--backdrop-filter);}[data-theme="dark"] #page-header.nav-fixed #nav {  background: rgba(0, 0, 0, 0.7) !important;}/* 夜间模式遮罩 */[data-theme="dark"] #recent-posts > .recent-post-item,[data-theme="dark"] #aside-content .card-widget,[data-theme="dark"] div#post,[data-theme="dark"] div#archive,[data-theme="dark"] div#page {  background: var(--trans-dark);}/* 夜间模式页脚页头遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}/* 阅读模式 */.read-mode #aside-content .card-widget {  background: rgba(158, 204, 171, 0.5) !important;}.read-mode div#post {  background: rgba(158, 204, 171, 0.5) !important;}/* 夜间模式下的阅读模式 */[data-theme="dark"] .read-mode #aside-content .card-widget {  background: rgba(25, 25, 25, 0.9) !important;  color: #ffffff;}[data-theme="dark"] .read-mode div#post {  background: rgba(25, 25, 25, 0.9) !important;  color: #ffffff;}/* 鼠标样式 */#cursor {  position: fixed;  width: 16px;  height: 16px;  /* 这里改变跟随的底色 */  background: var(--theme-color);  border-radius: 8px;  opacity: 0.6;  z-index: 10086;  pointer-events: none;  transition: 0.2s ease-in-out;  transition-property: background, opacity, transform;}#cursor.hidden {  opacity: 0.3;}#cursor.hover {  opacity: 0.6;  transform: scale(2.5);  -webkit-transform: scale(2.5);  -moz-transform: scale(2.5);  -ms-transform: scale(2.5);  -o-transform: scale(2.5);}#cursor.active {  opacity: 0.7;  transform: scale(0.5);  -webkit-transform: scale(0.5);  -moz-transform: scale(0.5);  -ms-transform: scale(0.5);  -o-transform: scale(0.5);}#cursor {  /* 这里改变跟随的底色 */  background: rgb(23, 177, 208);}@font-face {  /* 为载入的字体取名字(随意) */  font-family: 'YSHST';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/优设好身体.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/OneGraph.css"/>
      <url>/css/OneGraph.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/flipcountdown.css"/>
      <url>/css/flipcountdown.css</url>
      
        <content type="html"><![CDATA[.xdsoft_flipcountdown{display:inline-block;}.xdsoft_flipcountdown .xdsoft_digit{float:left;background-repeat:no-repeat;}.xdsoft_flipcountdown .xdsoft_clearex{clear:both;float:none;}.xdsoft_flipcountdown .xdsoft_digit{background-position:0px 0px;}.xdsoft_flipcountdown .xdsoft_digit.xdsoft_separator,.xdsoft_flipcountdown .xdsoft_digit.xdsoft_dot{opacity:0.9;}.xdsoft_flipcountdown.xdsoft_size_lg .xdsoft_digit{width:53px;height:76px;background-image:url(/img/digit-lg.png);}.xdsoft_flipcountdown.xdsoft_size_lg .xdsoft_digit.xdsoft_space,.xdsoft_flipcountdown.xdsoft_size_lg .xdsoft_digit.xdsoft_separator,.xdsoft_flipcountdown.xdsoft_size_lg .xdsoft_digit.xdsoft_dot{width:14px;background-position:-19px -4620px;}.xdsoft_flipcountdown.xdsoft_size_lg .xdsoft_digit.xdsoft_dot{background-position:-41px -4620px;}.xdsoft_flipcountdown.xdsoft_size_lg .xdsoft_digit.xdsoft_space{background-position:-100px -4620px;}.xdsoft_flipcountdown.xdsoft_size_md .xdsoft_digit{width:36px;height:51px;background-image:url(/img/digit-md.png);}.xdsoft_flipcountdown.xdsoft_size_md .xdsoft_digit.xdsoft_space,.xdsoft_flipcountdown.xdsoft_size_md .xdsoft_digit.xdsoft_separator,.xdsoft_flipcountdown.xdsoft_size_md .xdsoft_digit.xdsoft_dot{width:10px;background-position:-13px -3120px;}.xdsoft_flipcountdown.xdsoft_size_sm .xdsoft_digit{width:24px;height:34px;background-image:url(/img/digit-sm.png);}.xdsoft_flipcountdown.xdsoft_size_sm .xdsoft_digit.xdsoft_space,.xdsoft_flipcountdown.xdsoft_size_sm .xdsoft_digit.xdsoft_separator,.xdsoft_flipcountdown.xdsoft_size_sm .xdsoft_digit.xdsoft_dot{width:10px;background-position:-6px -2100px;}.xdsoft_flipcountdown.xdsoft_size_xs .xdsoft_digit{width:16px;height:23px;background-image:url(/img/digit-xs.png);}.xdsoft_flipcountdown.xdsoft_size_xs .xdsoft_digit.xdsoft_space,.xdsoft_flipcountdown.xdsoft_size_xs .xdsoft_digit.xdsoft_separator,.xdsoft_flipcountdown.xdsoft_size_xs .xdsoft_digit.xdsoft_dot{width:5px;background-position:-5px -1440px;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/progress_bar.css"/>
      <url>/css/progress_bar.css</url>
      
        <content type="html"><![CDATA[.pace {    -webkit-pointer-events: none;    pointer-events: none;    -webkit-user-select: none;    -moz-user-select: none;    user-select: none;    z-index: 2000;    position: fixed;    margin: auto;    top: 4px;    left: 0;    right: 0;    height: 8px;    border-radius: 8px;    width: 7rem;    background: #eaecf2;    border: 1px #e3e8f7;    overflow: hidden}.pace-inactive .pace-progress {    opacity: 0;    transition: .3s ease-in}.pace .pace-progress {    -webkit-box-sizing: border-box;    -moz-box-sizing: border-box;    -ms-box-sizing: border-box;    -o-box-sizing: border-box;    box-sizing: border-box;    -webkit-transform: translate3d(0, 0, 0);    -moz-transform: translate3d(0, 0, 0);    -ms-transform: translate3d(0, 0, 0);    -o-transform: translate3d(0, 0, 0);    transform: translate3d(0, 0, 0);    max-width: 200px;    position: absolute;    z-index: 2000;    display: block;    top: 0;    right: 100%;    height: 100%;    width: 100%;    /* linear-gradient(to right, #3494e6, #ec6ead) */    background: linear-gradient(to right, #43cea2, #3866ca);    animation: gradient 2s ease infinite;    background-size: 200%}.pace.pace-inactive {    opacity: 0;    transition: .3s;    top: -8px}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/anzhiyu.js"/>
      <url>/js/anzhiyu.js</url>
      
        <content type="html"><![CDATA[var anzhiyu_musicPlaying = false;var anzhiyu_musicStretch = false;var anzhiyu_musicFirst = false;var anzhiyu = {  //切换音乐播放状态  musicToggle: function (changePaly = true) {    if (!anzhiyu_musicFirst) {      musicBindEvent();      anzhiyu_musicFirst = true;    }    let msgPlay = '<i class="fa-solid fa-play"></i><span>播放音乐</span>'; // 此處可以更改為你想要顯示的文字    let msgPause = '<i class="fa-solid fa-pause"></i><span>暂停音乐</span>'; // 同上，但兩處均不建議更改    if (anzhiyu_musicPlaying) {      document.querySelector("#nav-music").classList.remove("playing");      document.getElementById("menu-music-toggle").innerHTML = msgPlay;      document.getElementById("nav-music-hoverTips").innerHTML = "音乐已暂停";      document.querySelector("#consoleMusic").classList.remove("on");      anzhiyu_musicPlaying = false;      document.querySelector("#nav-music").classList.remove("stretch");      anzhiyu_musicStretch = false;    } else {      document.querySelector("#nav-music").classList.add("playing");      document.getElementById("menu-music-toggle").innerHTML = msgPause;      document.querySelector("#consoleMusic").classList.add("on");      anzhiyu_musicPlaying = true;      document.querySelector("#nav-music").classList.add("stretch");      anzhiyu_musicStretch = true;    }    if (changePaly) document.querySelector("#nav-music meting-js").aplayer.toggle();  },  // 音乐伸缩  musicTelescopic: function () {    if (anzhiyu_musicStretch) {      document.querySelector("#nav-music").classList.remove("stretch");      anzhiyu_musicStretch = false;    } else {      document.querySelector("#nav-music").classList.add("stretch");      anzhiyu_musicStretch = true;    }  },  //音乐上一曲  musicSkipBack: function () {    document.querySelector("#nav-music meting-js").aplayer.skipBack();  },  //音乐下一曲  musicSkipForward: function () {    document.querySelector("#nav-music meting-js").aplayer.skipForward();  },  //获取音乐中的名称  musicGetName: function () {    var x = $(".aplayer-title");    var arr = [];    for (var i = x.length - 1; i >= 0; i--) {      arr[i] = x[i].innerText;    }    return arr[0];  },};addRightMenuClickEvent();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/anzhiyufunction.js"/>
      <url>/js/anzhiyufunction.js</url>
      
        <content type="html"><![CDATA[// 音乐绑定事件function musicBindEvent() {    document.querySelector("#nav-music .aplayer-music").addEventListener("click", function () {      anzhiyu.musicTelescopic();    });    document.querySelector("#nav-music .aplayer-button").addEventListener("click", function () {      anzhiyu.musicToggle(false);    });  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cursor.js"/>
      <url>/js/cursor.js</url>
      
        <content type="html"><![CDATA[var CURSOR;Math.lerp = (a, b, n) => (1 - n) * a + n * b;const getStyle = (el, attr) => {    try {        return window.getComputedStyle            ? window.getComputedStyle(el)[attr]            : el.currentStyle[attr];    } catch (e) {}    return "";};class Cursor {    constructor() {        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    move(left, top) {        this.cursor.style["left"] = `${left}px`;        this.cursor.style["top"] = `${top}px`;    }    create() {        if (!this.cursor) {            this.cursor = document.createElement("div");            this.cursor.id = "cursor";            this.cursor.classList.add("hidden");            document.body.append(this.cursor);        }        var el = document.getElementsByTagName('*');        for (let i = 0; i < el.length; i++)            if (getStyle(el[i], "cursor") == "pointer")                this.pt.push(el[i].outerHTML);        document.body.appendChild((this.scr = document.createElement("style")));        // 这里改变鼠标指针的颜色 由svg生成        this.scr.innerHTML = `* {cursor: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8' width='8px' height='8px'><circle cx='4' cy='4' r='4' opacity='.5'/></svg>") 4 4, auto}`;    }    refresh() {        this.scr.remove();        this.cursor.classList.remove("hover");        this.cursor.classList.remove("active");        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    init() {        document.onmouseover  = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.add("hover");        document.onmouseout   = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.remove("hover");        document.onmousemove  = e => {(this.pos.curr == null) && this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = {x: e.clientX - 8, y: e.clientY - 8}; this.cursor.classList.remove("hidden");};        document.onmouseenter = e => this.cursor.classList.remove("hidden");        document.onmouseleave = e => this.cursor.classList.add("hidden");        document.onmousedown  = e => this.cursor.classList.add("active");        document.onmouseup    = e => this.cursor.classList.remove("active");    }    render() {        if (this.pos.prev) {            this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15);            this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15);            this.move(this.pos.prev.x, this.pos.prev.y);        } else {            this.pos.prev = this.pos.curr;        }        requestAnimationFrame(() => this.render());    }}(() => {    CURSOR = new Cursor();    // 需要重新获取列表时，使用 CURSOR.refresh()})();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/codeblock.js"/>
      <url>/js/codeblock.js</url>
      
        <content type="html"><![CDATA[hexo.extend.filter.register('after_post_render', function (data) {    while (/<figure class="highlight ([a-zA-Z\+\-\/\#]+)">.*?<\/figure>/.test(data.content)) {        data.content = data.content.replace(/<figure class="highlight ([a-zA-Z\+\-\/\#]+)">.*?<\/figure>/, function () {            var language = RegExp.$1 || 'code'            var lastMatch = RegExp.lastMatch            if (language=='plain'){                language='code';            }            lastMatch = lastMatch.replace(/<figure class="highlight /, '<figure class="iseeu highlight ')            return '<div class="highlight-wrap" data-rel="'                + language.replace(language[0],language[0].toUpperCase()) + '">' + lastMatch + '</div>'        })    }    return data})]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/flipcountdown.js"/>
      <url>/js/flipcountdown.js</url>
      
        <content type="html"><![CDATA[/** * @preserve jQuery flipcountdown plugin v3.0.4 * @homepage http://xdsoft.net/jqplugins/flipcountdown/ * (c) 2013, Chupurnov Valeriy. */(function($){    jQuery.fn.flipCountDown = jQuery.fn.flipcountdown = function( _options ){        var default_options = {                showHour:true,                showMinute:true,                showSecond:true,                am:false,                    tzoneOffset:0,                speedFlip:60,                period:1000,                tick:function(){                                return new Date();                            },                autoUpdate:true,                size:'md'            },                sizes = {                lg:77,                md:52,                sm:35,                xs:24            },                createFlipCountDown = function( $box ){                var $flipcountdown = $('<div class="xdsoft_flipcountdown"></div>'),                    $clearex = $('<div class="xdsoft_clearex"></div>'),                         options = $.extend({},default_options),                        timer = 0,                        _animateRange = function( box,a,b ){                        _animateOne( box,a,(a>b&&!(a==9&&b==0))?-1:1,!(a==9&&b==0)?Math.abs(a-b):1 );                    },                        _animateOne = function( box,a,arrow,range ){                        if( range<1 )                            return;                            _setMargin(box,-(a*6*sizes[options.size]+1),1,arrow,function(){                            _animateOne(box,a+arrow,arrow,range-1);                        },range);                    },                        _setMargin = function( box, marginTop, rec, arrow,callback,range){                        if( marginTop<=-sizes[options.size]*60 )                            marginTop = -1;                        box.css('background-position','0px '+marginTop+'px' );                        if( rec<=6 ){                            setTimeout(function(){                                _setMargin(box, marginTop-arrow*sizes[options.size], ++rec, arrow, callback,range);                            },parseInt(options.speedFlip/range));                        }else                            callback();                    },                        blocks = [],                        _typeCompare= function ( a,b ){                        return a&&b&&(                                    (a==b)||                                    (/^[0-9]+$/.test(a+''+b))||                                    (/^[:.\s]+$/.test(a+''+b))                                );                    },                        _generate = function( chars ){                        if( !(chars instanceof Array) || !chars.length )                            return false;                        for( var i = 0, n = chars.length;i<n;i++ ){                            if( !blocks[i] ){                                blocks[i] = $('<div class="xdsoft_digit"></div>');                                $clearex.before(blocks[i]);                            }                            if( blocks[i].data('value')!=chars[i] ){                                if( !_typeCompare(blocks[i].data('value'),chars[i]) ){                                    blocks[i]                                        .removeClass('xdsoft_separator')                                        .removeClass('xdsoft_dot');                                    switch( chars[i] ){                                        case ':':blocks[i].addClass('xdsoft_separator');break;                                        case '.':blocks[i].addClass('xdsoft_dot');break;                                        case ' ':blocks[i].addClass('xdsoft_space');break;                                    }                                }                                if( !isNaN(chars[i]) ){                                    var old = parseInt(blocks[i].data('value')),                                        ii = parseInt(blocks[i].data('i')),                                        crnt = parseInt(chars[i]);                                    if( isNaN(old)||i!=ii ){                                        old = (crnt-1)<0?9:crnt-1;                                    }                                    _animateRange(blocks[i],old,crnt);                                }                                blocks[i].data('value',chars[i]);                                blocks[i].data('i',i);                            }                        }                        if( blocks.length>chars.length ){                            for(;i<blocks.length;i++ ){                                blocks[i][0].parentNode.removeChild(blocks[i][0]);                                delete blocks[i];                            }                            blocks.splice(chars.length);                        }                        },                        counter = 0,                        _calcMoment = function(){                        var value = '1',chars = [];                        if(options.tick)                            value = (options.tick instanceof Function)?options.tick.call($box,counter):options.tick;                            if( typeof value!=='undefined' ){                            switch( value.constructor ){                                case Date:                                    var h = (value.getHours()+options.tzoneOffset)%(options.am?12:24);                                        if( options.showHour ){                                        chars.push(parseInt(h/10));                                        chars.push(h%10);                                    }                                        if( options.showHour && (options.showMinute || options.showSecond) )                                        chars.push(':');                                        if( options.showMinute ){                                        chars.push(parseInt(value.getMinutes()/10));                                        chars.push(value.getMinutes() % 10);                                    }                                        if( options.showMinute && options.showSecond )                                        chars.push(':');                                        if( options.showSecond ){                                        chars.push(parseInt(value.getSeconds()/10));                                        chars.push(value.getSeconds() % 10);                                    }                                break;                                case String:                                    chars = value.replace(/[^0-9\:\.\s]/g,'').split('');                                break;                                case Number:                                    chars = value.toString().split('');                                break;                            }                            _generate(chars);                        }                    };                    $flipcountdown                    .append($clearex)                    .on('xdinit.xdsoft',function(){                        clearInterval(timer);                        if( options.autoUpdate )                            timer = setInterval( _calcMoment,options.period );                        _calcMoment();                    });                    $box.data('setOptions',function( _options ){                    options = $.extend({},options,_options);                    if( !sizes[options.size] )                        options.size = 'lg';                    $flipcountdown                        .addClass('xdsoft_size_'+options.size)                        .trigger('xdinit.xdsoft');                });                $box.append($flipcountdown);            };        return this.each(function(){            var $box = $(this);            if( !$box.data('setOptions') ){                $box.addClass('xdsoft')                createFlipCountDown($box);            }            $box.data('setOptions')&&                $.isFunction($box.data('setOptions'))&&                    $box.data('setOptions')(_options);        });    }    })(jQuery);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[<div class="issues-api sites"api="https://api.github.com/repos/[GithubUsername]/[GithubReponame]/issues?sort=updated&state=open&page=1&per_page=100&labels=active"></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/light.js"/>
      <url>/js/light.js</url>
      
        <content type="html"><![CDATA[// 霓虹灯效果// 颜色数组var arr = ["#39c5bb", "#f14747", "#f1a247", "#f1ee47", "#b347f1", "#1edbff", "#ed709b", "#5636ed"];// 颜色索引var idx = 0;// 切换颜色function changeColor() {    // 仅夜间模式才启用    if (document.getElementsByTagName('html')[0].getAttribute('data-theme') == 'dark') {        if (document.getElementById("site-name"))            document.getElementById("site-name").style.textShadow = arr[idx] + " 0 0 15px";        if (document.getElementById("site-title"))            document.getElementById("site-title").style.textShadow = arr[idx] + " 0 0 15px";        if (document.getElementById("site-subtitle"))            document.getElementById("site-subtitle").style.textShadow = arr[idx] + " 0 0 10px";        if (document.getElementById("post-info"))            document.getElementById("post-info").style.textShadow = arr[idx] + " 0 0 5px";        try {            document.getElementsByClassName("author-info__name")[0].style.textShadow = arr[idx] + " 0 0 12px";            document.getElementsByClassName("author-info__description")[0].style.textShadow = arr[idx] + " 0 0 12px";        } catch {                    }        idx++;        if (idx == 8) {            idx = 0;        }    } else {        // 白天模式恢复默认        if (document.getElementById("site-name"))            document.getElementById("site-name").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("site-title"))            document.getElementById("site-title").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("site-subtitle"))            document.getElementById("site-subtitle").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("post-info"))            document.getElementById("post-info").style.textShadow = "#1e1e1ee0 1px 1px 1px";        try {            document.getElementsByClassName("author-info__name")[0].style.textShadow = "";            document.getElementsByClassName("author-info__description")[0].style.textShadow = "";        } catch {                    }    }}// 开启计时器window.onload = setInterval(changeColor, 1200);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.js"/>
      <url>/js/runtime.js</url>
      
        <content type="html"><![CDATA[$(function(){    var NY = Math.round((new Date('4/17/2019 00:00:00')).getTime()/1000); //Date修改为你的建站时间。    $('#runtime').flipcountdown({      size:"xs",//可以自定义翻页计时器大小。从大到小依次是lg、md、sm、xs。      tick:function(){        var nol = function(h){          return h>9?h:'0'+h;        }        varrange  = Math.abs(Math.round((new Date()).getTime()/1000)-NY),          secday = 86400, sechour = 3600,          days = parseInt(range/secday),          hours= parseInt((range%secday)/sechour),          min= parseInt(((range%secday)%sechour)/60),          sec= ((range%secday)%sechour)%60;        return nol(days)+' '+nol(hours)+' '+nol(min)+' '+nol(sec);      }    });  });]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/issues.js"/>
      <url>/js/issues.js</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[<div id="aplayer-oSEOhviA" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="4895239160" data-server="netease" data-type="playlist" data-mode="random" data-autoplay="false" data-listmaxheight="340px" data-preload="auto" data-theme="#e3f2f5" data-volume="0.4" mutex="true"></div>]]></content>
      
    </entry>
    
    
  
</search>
